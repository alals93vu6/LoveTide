# 🎮 互動系統完整設計 (重製版)

> GamePlay場景重製工程：完整的互動系統架構設計

---

## 🎯 概述

重製版互動系統針對移動角色互動問題進行了全面重新設計，採用7層Canvas架構和透明Button跟隨技術，實現了完整的場景互動體驗。

---

## 🏗️ 完整互動架構

### 🎨 **Canvas分層設計**
```
🖼️ 新版互動系統 Canvas 架構
├── Background Canvas (Order: 0) - 場景背景
├── Static Interaction Canvas (Order: 40) - 靜態物件互動 🆕
│   ├── 工作互動按鈕 (幫忙工作)
│   ├── 貓咪互動按鈕 (和貓互動) 
│   ├── 門口按鈕 (外出系統)
│   └── 酒類互動按鈕 (邀請喝酒)
├── Dynamic Character Canvas (Order: 50) - 動態角色互動 🆕
│   └── 由香互動Button (透明跟隨Spine)
├── Game UI Canvas (Order: 60) - 遊戲UI
├── Dialog Canvas (Order: 70) - 對話系統
├── Menu Canvas (Order: 80) - 選單系統
└── Popup Canvas (Order: 90) - 彈窗系統
```

---

## 🎮 場景互動系統

### 🏢 **工作時場景互動**

#### 📋 **主要互動選項** (Static Interaction Canvas)
```csharp
public enum WorkSceneInteraction
{
    HelpYukaWork,      // 幫忙由香工作
    CatInteraction,    // 和貓互動
    GoOutAlone,        // 自己獨自出門
    TalkToYuka         // 找由香對話 (Dynamic Character Canvas)
}
```

#### 💬 **由香對話子選單** (Dialog Canvas)
```csharp
public enum YukaDialogOption
{
    NormalTalk,        // 對話 (基礎互動)
    FlirtTalk,         // 調情 (需好感度)
    GoOutTogether,     // 和由香一起外出
    SexualInteraction  // 捉i (特殊解鎖條件)
}
```

### 🏠 **宿舍時場景互動**

#### 📋 **主要互動選項** (Static Interaction Canvas)
```csharp
public enum DormSceneInteraction
{
    InviteDrinking,    // 邀請由香一起喝酒
    TalkToYuka         // 找由香對話 (Dynamic Character Canvas)
}
```

#### 💬 **由香對話子選單** (與工作時相同)
- 對話、調情、一起外出、捉i
- 宿舍時「捉i」解鎖條件較工作時寬鬆

---

## 🔥 重大場景變更

### ⚠️ **夜晚場景統一化**

#### 🔄 **原設計 vs 新設計**
```
❌ 原設計:
夜晚時段 1-3:
├── 時段1: 由香在宿舍大廳
├── 時段2: 由香進入自己房間 ← 需額外場景
└── 時段3: 由香在宿舍大廳

✅ 新設計:
夜晚時段 1-3:
├── 時段1: 由香在宿舍大廳
├── 時段2: 由香在宿舍大廳 ← 簡化統一
└── 時段3: 由香在宿舍大廳
```

#### 🎯 **變更優勢**
- **簡化場景管理** - 不需要額外的由香房間場景
- **統一互動邏輯** - 所有宿舍時段使用相同系統
- **降低開發複雜度** - 減少場景切換和狀態管理
- **提升用戶體驗** - 玩家不會因找不到角色而困惑

---

## 🎯 技術實作架構

### 🎮 **InteractionManager 核心控制器**
```csharp
public class InteractionManager : MonoBehaviour
{
    [Header("場景狀態")]
    public bool isWorkTime;
    public int currentTimeSlot;
    
    [Header("互動系統")]
    public DynamicCharacterInteraction yukaInteraction;
    public StaticObjectInteraction sceneInteraction;
    
    [Header("Canvas引用")]
    public Canvas dynamicCharacterCanvas;
    public Canvas staticInteractionCanvas;
    
    // 🎯 根據時間和場景更新可用互動
    public void UpdateAvailableInteractions()
    {
        if (isWorkTime)
        {
            EnableWorkSceneInteractions();
        }
        else
        {
            EnableDormSceneInteractions();
        }
        
        // 夜晚場景統一處理
        if (currentTimeSlot >= 7)
        {
            SetYukaLocationToDormHall();
        }
    }
    
    void EnableWorkSceneInteractions()
    {
        // 啟用工作場景的4個主要互動
        sceneInteraction.EnableInteraction("HelpWork", true);
        sceneInteraction.EnableInteraction("CatPlay", true);
        sceneInteraction.EnableInteraction("GoOutAlone", true);
        
        // 由香對話始終可用 (Dynamic Character Canvas)
        yukaInteraction.EnableInteraction(true);
    }
    
    void EnableDormSceneInteractions()
    {
        // 啟用宿舍場景的2個主要互動
        sceneInteraction.EnableInteraction("InviteDrinking", true);
        
        // 由香對話始終可用 (Dynamic Character Canvas)
        yukaInteraction.EnableInteraction(true);
    }
}
```

### 🎨 **DynamicCharacterInteraction 動態角色系統**
```csharp
public class DynamicCharacterInteraction : MonoBehaviour
{
    [Header("由香角色引用")]
    public Transform yukaSpineTransform;
    public Button yukaInteractionButton;
    
    [Header("Button設定")]
    public Vector2 buttonSize = new Vector2(100, 150);
    public Vector2 buttonOffset = Vector2.zero;
    
    void Update()
    {
        // 透明Button跟隨由香Spine角色移動
        UpdateButtonPosition();
        
        // 根據場景狀態調整可見性
        UpdateButtonVisibility();
    }
    
    void UpdateButtonPosition()
    {
        if (yukaSpineTransform != null)
        {
            // World Space → Screen Space 座標轉換
            Vector3 worldPos = yukaSpineTransform.position + (Vector3)buttonOffset;
            Vector2 screenPos = Camera.main.WorldToScreenPoint(worldPos);
            yukaInteractionButton.transform.position = screenPos;
        }
    }
    
    // 🎯 點擊由香時顯示對話選單
    public void OnYukaClicked()
    {
        ShowYukaDialogMenu();
    }
    
    void ShowYukaDialogMenu()
    {
        var availableOptions = GetAvailableDialogOptions();
        dialogSystem.ShowDialogMenu(availableOptions);
    }
    
    List<YukaDialogOption> GetAvailableDialogOptions()
    {
        var options = new List<YukaDialogOption>();
        
        // 基礎對話始終可用
        options.Add(YukaDialogOption.NormalTalk);
        
        // 調情需要好感度
        if (CheckAffectionLevel(RequiredAffectionForFlirt))
        {
            options.Add(YukaDialogOption.FlirtTalk);
        }
        
        // 一起外出需要時間條件
        if (CheckTimeAvailableForGoingOut())
        {
            options.Add(YukaDialogOption.GoOutTogether);
        }
        
        // 捉i需要特殊條件
        if (CheckSexualInteractionUnlocked())
        {
            options.Add(YukaDialogOption.SexualInteraction);
        }
        
        return options;
    }
}
```

### 🏠 **StaticObjectInteraction 靜態物件系統**
```csharp
public class StaticObjectInteraction : MonoBehaviour
{
    [Header("工作場景互動")]
    public Button helpWorkButton;
    public Button catInteractionButton;
    public Button goOutAloneButton;
    
    [Header("宿舍場景互動")]
    public Button inviteDrinkingButton;
    
    [Header("互動配置")]
    public Dictionary<string, InteractionData> interactionConfigs;
    
    public void EnableInteraction(string interactionName, bool enable)
    {
        switch (interactionName)
        {
            case "HelpWork":
                helpWorkButton.gameObject.SetActive(enable);
                break;
            case "CatPlay":
                catInteractionButton.gameObject.SetActive(enable);
                break;
            case "GoOutAlone":
                goOutAloneButton.gameObject.SetActive(enable);
                break;
            case "InviteDrinking":
                inviteDrinkingButton.gameObject.SetActive(enable);
                break;
        }
    }
    
    // 🎯 處理靜態物件互動
    public void HandleInteraction(string interactionType)
    {
        var interactionData = interactionConfigs[interactionType];
        
        // 執行互動邏輯
        ExecuteInteraction(interactionData);
        
        // 更新數值
        UpdatePlayerStats(interactionData);
        
        // 推進時間
        AdvanceTime(interactionData.timeCost);
    }
}
```

---

## 🔄 解鎖條件系統

### 🎯 **「捉i」解鎖條件設計**
```csharp
public class SexualInteractionUnlockChecker : MonoBehaviour
{
    [Header("解鎖條件配置")]
    public int requiredProgressForDorm = 50;      // 宿舍時需要的進度
    public int requiredProgressForWork = 80;      // 工作時需要的進度
    public int requiredAffectionForWork = 70;     // 工作時需要的額外好感度
    
    public bool CheckSexualInteractionUnlocked(bool isWorkTime)
    {
        int currentProgress = GetCurrentStoryProgress();
        int currentAffection = GetCurrentAffection();
        
        if (isWorkTime)
        {
            // 工作時：需要更高進度 + 更高好感度
            return currentProgress >= requiredProgressForWork && 
                   currentAffection >= requiredAffectionForWork;
        }
        else
        {
            // 宿舍時：只需要基礎進度
            return currentProgress >= requiredProgressForDorm;
        }
    }
}
```

### 💕 **其他互動解鎖條件**
```csharp
public class InteractionUnlockManager : MonoBehaviour
{
    // 調情解鎖條件
    public bool CheckFlirtTalkUnlocked()
    {
        return GetCurrentAffection() >= 20;
    }
    
    // 一起外出解鎖條件
    public bool CheckGoOutTogetherUnlocked()
    {
        return GetCurrentAffection() >= 30 && 
               GetCurrentTimeSlot() <= 6; // 不能太晚
    }
    
    // 邀請喝酒解鎖條件 (宿舍專用)
    public bool CheckInviteDrinkingUnlocked()
    {
        return GetCurrentAffection() >= 40 && 
               !isWorkTime; // 只在宿舍時可用
    }
}
```

---

## 🎨 視覺反饋系統

### ✨ **互動反饋設計**
```csharp
public class InteractionFeedbackSystem : MonoBehaviour
{
    [Header("由香互動反饋")]
    public GameObject yukaHoverIndicator;
    public ParticleSystem yukaClickEffect;
    
    [Header("靜態物件反饋")]
    public Dictionary<string, GameObject> objectHoverEffects;
    
    // 🎯 由香Hover效果
    public void OnYukaHoverEnter()
    {
        yukaHoverIndicator.SetActive(true);
        PlayHoverAnimation(yukaInteractionButton);
    }
    
    public void OnYukaHoverExit()
    {
        yukaHoverIndicator.SetActive(false);
        StopHoverAnimation(yukaInteractionButton);
    }
    
    public void OnYukaClicked()
    {
        yukaClickEffect.Play();
        PlayClickAnimation(yukaInteractionButton);
    }
    
    // 🎯 靜態物件反饋
    public void OnStaticObjectHover(string objectName, bool isEnter)
    {
        if (objectHoverEffects.ContainsKey(objectName))
        {
            objectHoverEffects[objectName].SetActive(isEnter);
        }
    }
}
```

---

## 📊 場景狀態管理

### 🔄 **場景切換邏輯**
```csharp
public class SceneStateManager : MonoBehaviour
{
    [Header("場景狀態")]
    public bool isWorkTime;
    public int currentTimeSlot;
    public SceneLocation yukaCurrentLocation;
    
    public enum SceneLocation
    {
        WorkPlace,
        DormHall,
        YukaRoom  // 已棄用，改為統一在DormHall
    }
    
    // 🕐 時間推進時更新場景狀態
    public void OnTimeAdvanced(int newTimeSlot)
    {
        currentTimeSlot = newTimeSlot;
        
        // 判斷工作時間 vs 宿舍時間
        isWorkTime = (newTimeSlot >= 1 && newTimeSlot <= 6);
        
        // 🔥 重要變更：夜晚統一在宿舍大廳
        if (newTimeSlot >= 7)
        {
            yukaCurrentLocation = SceneLocation.DormHall;
        }
        else if (isWorkTime)
        {
            yukaCurrentLocation = SceneLocation.WorkPlace;
        }
        else
        {
            yukaCurrentLocation = SceneLocation.DormHall;
        }
        
        // 更新互動系統
        interactionManager.UpdateAvailableInteractions();
    }
}
```

---

## 💬 Claude 開發提示

### 🎯 **重製版重點**
1. **Canvas分層架構** - 嚴格按照7層Canvas設計
2. **透明Button跟隨** - 核心技術：World/Screen座標轉換
3. **場景統一化** - 夜晚場景不再有由香房間切換
4. **模組化設計** - 動態角色與靜態物件完全分離

### 🔧 **開發注意事項**
- **性能優化** - Update()中的座標轉換要高效
- **邊界檢查** - 確保由香在螢幕範圍內才顯示Button
- **狀態同步** - 確保所有管理器狀態一致
- **回滾安全** - 新舊系統完全分離

### 🚀 **擴展性考量**
- 未來可輕鬆添加新的靜態物件互動
- 動態角色系統可擴展支援多角色
- Canvas架構支援更複雜的UI層級
- 解鎖系統可配置化管理

---

**設計版本**: 2.0 (重製版)  
**最後更新**: 2025-08-17  
**狀態**: 🔥 **準備實作**

> 🎮 **重製版核心**: 透過全新的Canvas分層架構和透明Button跟隨技術，實現了完美的移動角色互動體驗，同時簡化了場景管理邏輯，為未來擴展奠定了堅實基礎！