# 🎭 劇情播放系統架構

> LoveTide 劇情播放系統的完整技術架構設計，包含對話管理、場景控制和劇情流程管理

---

## 🎯 概述

劇情播放系統架構是 LoveTide 遊戲的核心敘事引擎，負責管理對話展示、角色演出、場景切換和劇情進度控制。系統採用分層架構設計，通過JSON驅動的內容管理和事件驅動的流程控制，實現了高度靈活和可擴展的劇情播放體驗。

---

## 🏗️ 實際系統架構圖

> ⚠️ **重要**: 以下為基於實際程式碼分析的真實架構，是未來重構的重要參考藍圖

```
🎭 LoveTide 劇情播放系統實際架構
│
├── 🎮 核心控制層 (Core Control Layer) - 實際存在
│   ├── GameManagerTest.cs - 養成模式主控制器
│   ├── GamePlayingManagerDrama.cs - 劇情模式主控制器
│   ├── SettleManager.cs - 劇情結算管理器
│   └── NumericalRecords.cs - 數值與進度記錄系統
│
├── 📊 數據管理層 (Data Management Layer) - 實際存在
│   ├── JsonDataManager.cs - 核心JSON數據管理器 ⭐
│   ├── DialogData.cs - 舊版對話數據結構
│   ├── DataStructures.cs - 新版數據結構定義
│   └── SaveDataManager.cs - 存檔數據管理器
│
├── 📡 通訊廣播層 (Communication Layer) - 實際存在
│   ├── EventBus.cs - 核心事件廣播系統 ⭐
│   └── 事件驅動的模組間通訊機制
│
├── 🎨 展示渲染層 (Presentation Layer) - 實際存在
│   ├── TextBoxDrama.cs - 劇情對話文字渲染器
│   ├── TextBoxTestPlaying.cs - 養成模式對話渲染器
│   ├── ActorManagerDrama.cs - 劇情角色演出管理器
│   ├── ActorManagerTest.cs - 養成模式角色管理器
│   ├── CGDisplay.cs - CG場景展示器
│   └── PlayerCtrlDrama.cs - 劇情玩家控制器
│
├── 🎵 多媒體層 (Multimedia Layer) - 部分存在
│   ├── AudioManager - 音效管理 (推測存在)
│   └── BackgroundController - 背景控制 (推測存在)
│
└── 🔄 實際數據流程 (Actual Data Flow)
    GameManager記錄進度 → 玩家互動觸發 → JsonDataManager拿取數據 
    → EventBus廣播事件 → 各接收程式依index播放 → 更新進度儲存
```

### 🎯 **核心架構特點** (基於實際程式碼)
- **雙模式管理**: 養成模式(GameManagerTest) + 劇情模式(GamePlayingManagerDrama)
- **JSON驅動**: JsonDataManager.cs 為核心數據引擎
- **事件廣播**: EventBus.cs 實現模組間解耦通訊
- **進度持久化**: NumericalRecords.cs 負責進度和數值管理
- **分層渲染**: 不同模式的TextBox和ActorManager

---

## 🎯 新版章節配置系統架構 (計劃中)

> **🚧 重要**: 這是計劃中的新版章節配置系統，旨在解決角色命名和資源管理問題

### 📋 章節配置JSON格式設計

```json
{
  "ChapterConfig": {
    "StoryType": "主線",
    "Chapter": 1,
    "ChapterName": "序章",
    "MainHeroine": "Yuka",
    "SupportingCast": {
      "Supporter1": "boss",
      "Supporter2": null,
      "Supporter3": null,
      "Supporter4": null,
      "Supporter5": null
    },
    "ResourcePaths": {
      "CGPath": "CG/Main/Chapter_01/",
      "SpineCGPath": "SpineCG/Main/Chapter_01/",
      "VoicePath": "Voice/Main/Chapter_01/",
      "BackgroundPath": "Backgrounds/Main/Chapter_01/"
    }
  }
}
```

### 📋 支線章節配置範例

```json
{
  "ChapterConfig": {
    "StoryType": "支線",
    "Chapter": "NANA支線",
    "ChapterNumber": 3,
    "MainHeroine": "nana",
    "SupportingCast": {
      "Supporter1": "朋友A",
      "Supporter2": "朋友B",
      "Supporter3": "兄弟A",
      "Supporter4": "酒保",
      "Supporter5": null
    },
    "ResourcePaths": {
      "CGPath": "CG/SideStory/Nana/Chapter_03/",
      "SpineCGPath": "SpineCG/SideStory/Nana/Chapter_03/",
      "VoicePath": "Voice/SideStory/Nana/Chapter_03/",
      "BackgroundPath": "Backgrounds/SideStory/Nana/Chapter_03/"
    }
  }
}
```

### 🔄 優化後的對話JSON格式

```json
{
  "DialogIndex": "1",
  "ActorType": "female",        // 廣義角色類型（取代具體角色名）
  "CostumeIndex": "01",         // 造型編號
  "HasVoice": true,             // 是否說話的BOOL
  "Dialog": "這裡就是電影裡演的一樣到到不行......",
  "ActorFace": "Anxious",
  "ActorAnimator": "NoActor",
  "FadeType": "FALSE",
  "CGController": "NoActor",
  "Spinecontroller": "NoActor",
  "ActorPosition": "0"
}
```

### 🎭 角色映射系統設計

```csharp
public class ChapterActorMapper : MonoBehaviour
{
    [Header("章節配置")]
    public ChapterConfig currentChapterConfig;
    
    // 根據廣義角色類型獲取具體角色
    public string GetActualActor(string genericActorType)
    {
        switch (genericActorType)
        {
            case "female":
                return currentChapterConfig.MainHeroine;
            case "Supporter1":
                return currentChapterConfig.SupportingCast.Supporter1;
            case "Supporter2":
                return currentChapterConfig.SupportingCast.Supporter2;
            // ... 其他映射
            default:
                return genericActorType;
        }
    }
    
    // 語音播放邏輯（計劃中）
    public void PlayVoiceIfNeeded(string actorType, bool hasVoice)
    {
        if (hasVoice)
        {
            string actualActor = GetActualActor(actorType);
            string voicePath = GetVoicePath(actualActor);
            // 播放對應語音並index++
        }
    }
}
```

### 🗂️ 需要補齊的檔案清單

**🚧 核心系統檔案（需新增）**:
- `ChapterConfigManager.cs` - 章節配置管理器
- `ChapterActorMapper.cs` - 章節角色映射器
- `ResourcePathResolver.cs` - 資源路徑解析器
- `VoicePlaybackController.cs` - 語音播放控制器

**🚧 配置檔案（需新增）**:
- `ChapterConfigs/Main/Chapter_01_Config.json` - 主線第一章配置
- `ChapterConfigs/SideStory/Nana/Chapter_03_Config.json` - Nana支線配置
- 各章節的資源路徑配置檔案

**🚧 現有檔案（需修改）**:
- `GamePlayingManagerDrama.cs` - 整合新的章節配置系統
- `JsonDataManager.cs` - 支援新的JSON格式
- `DataStructures.cs` - 新增章節配置數據結構

---

## 📊 實際數據管理層架構

### 🌟 JsonDataManager - 核心JSON數據管理器 (實際存在)

> **重要**: 這是整個劇情系統的核心數據引擎，負責所有JSON的載入、解析和查詢

```csharp
public class JsonDataManager : MonoBehaviour
{
    [Header("JSON資料管理")]
    public static JsonDataManager Instance;
    
    // 核心功能：根據事件索引和對話索引獲取特定對話
    public DialogItem GetDialogByEventAndIndex(int eventIndex, int dialogIndex)
    {
        // 實際的JSON查詢邏輯
        // 返回對應index的對話數據
    }
    
    // JSON檔案載入和解析
    public void LoadJsonData(string fileName)
    {
        // 載入指定的JSON檔案
        // 使用JsonHelper進行陣列解析
    }
    
    // 數據查詢和過濾
    public List<DialogItem> GetDialogsByCondition(Func<DialogItem, bool> condition)
    {
        // 根據條件查詢對話數據
    }
}
```

### 📋 實際JSON數據結構 (Main_01.json格式)

```csharp
[System.Serializable]
public class MainStoryDialogItem
{
    public string DialogIndex;        // "1", "2", "3"... 對話索引
    public string ActorName;          // "Narrator", "Player", "Yuka", "Boss"
    public string Dialog;             // 對話內容文字
    public string ActorFace;          // "Anxious", "Happy", "Neutral", "Sad", "Nervous"
    public string ActorAnimator;      // "Idle", "NoActor"
    public string FadeType;           // "TRUE", "FALSE" - 場景淡入淡出
    public string CGController;       // CG控制器名稱
    public string Spinecontroller;    // Spine動畫控制器
    public string ActorPosition;      // "0", "1", "2", "3" - 角色位置
    public string Backgroundcomtroller; // "Islands_01", "KaraOK_01", "Tavem", "RoomA_01"
}
```

### 🔄 實際數據載入流程

```csharp
// 實際使用的數據載入邏輯
public class ActualDataLoader
{
    // 1. GameManager 記錄當前進度index
    public int currentDialogIndex = 0;
    
    // 2. 根據index從JsonDataManager獲取數據
    public MainStoryDialogItem GetCurrentDialog()
    {
        return JsonDataManager.Instance.GetDialogByIndex(currentDialogIndex);
    }
    
    // 3. 廣播數據給各個接收程式
    public void BroadcastDialogData(MainStoryDialogItem dialogData)
    {
        EventBus.Instance.Post("DialogDataReady", dialogData);
    }
    
    // 4. 更新進度並儲存
    public void AdvanceProgress()
    {
        currentDialogIndex++;
        NumericalRecords.Instance.SaveProgress(currentDialogIndex);
    }
}
```

---

## 📡 實際通訊廣播層架構

### 🌟 EventBus - 核心事件廣播系統 (實際存在)

> **重要**: 這是模組間通訊的核心，實現了完全解耦的事件驅動架構

```csharp
public class EventBus : MonoBehaviour
{
    public static EventBus Instance;
    
    [Header("事件系統")]
    private Dictionary<string, UnityEvent> eventDictionary;
    private Dictionary<string, List<System.Action<object>>> callbackEvents;
    
    // 事件訂閱 - 各接收程式用此方法註冊
    public void Subscribe(string eventName, System.Action<object> callback)
    {
        if (!callbackEvents.ContainsKey(eventName))
            callbackEvents[eventName] = new List<System.Action<object>>();
        callbackEvents[eventName].Add(callback);
    }
    
    // 事件廣播 - GameManager用此方法廣播數據
    public void Post(string eventName, object data = null)
    {
        if (callbackEvents.ContainsKey(eventName))
        {
            foreach (var callback in callbackEvents[eventName])
            {
                callback.Invoke(data);
            }
        }
    }
    
    // 動態事件緩衝機制
    public void BufferEvent(string eventName, object data)
    {
        // 緩衝事件直到接收者準備好
    }
}
```

### 🎯 實際事件廣播流程

```
📱 玩家點擊觸發
    ↓
🎮 GameManager 檢查當前index
    ↓
📊 JsonDataManager 根據index拿取數據
    ↓
📡 EventBus 廣播 "DialogDataReady" 事件
    ↓
🎭 各接收程式同時收到廣播:
    ├── TextBoxDrama.cs (更新對話文字)
    ├── ActorManagerDrama.cs (更新角色動作)
    ├── CGDisplay.cs (更新背景CG)
    └── 其他相關系統...
    ↓
💾 NumericalRecords 更新並儲存進度
```

---

## 📊 舊版劇情數據層架構

### 🗂️ DialogDataManager 對話數據管理器
```csharp
public class DialogDataManager : MonoBehaviour
{
    [Header("數據配置")]
    public string dialogDataPath = "DialogData/";
    public DialogData[] loadedDialogData;
    
    [Header("緩存管理")]
    public int maxCacheSize = 50;
    private Dictionary<string, DialogData> dialogCache;
    private Queue<string> cacheQueue;
    
    #region 單例模式
    public static DialogDataManager Instance { get; private set; }
    
    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
            InitializeDataManager();
        }
        else
        {
            Destroy(gameObject);
        }
    }
    #endregion
    
    // 🚀 初始化數據管理器
    void InitializeDataManager()
    {
        dialogCache = new Dictionary<string, DialogData>();
        cacheQueue = new Queue<string>();
        
        // 預載入核心對話數據
        PreloadCoreDialogData();
    }
    
    // 📖 載入對話數據
    public DialogData LoadDialogData(string dialogID)
    {
        // 優先從緩存中獲取
        if (dialogCache.ContainsKey(dialogID))
        {
            return dialogCache[dialogID];
        }
        
        // 從資源中載入
        DialogData dialogData = LoadDialogFromResources(dialogID);
        
        if (dialogData != null)
        {
            // 加入緩存
            AddToCache(dialogID, dialogData);
            return dialogData;
        }
        
        Debug.LogError($"找不到對話數據: {dialogID}");
        return null;
    }
    
    // 📦 從資源載入對話數據
    DialogData LoadDialogFromResources(string dialogID)
    {
        string resourcePath = $"{dialogDataPath}{dialogID}";
        
        try
        {
            TextAsset jsonFile = Resources.Load<TextAsset>(resourcePath);
            if (jsonFile != null)
            {
                DialogData dialogData = JsonUtility.FromJson<DialogData>(jsonFile.text);
                ProcessDialogData(dialogData);
                return dialogData;
            }
        }
        catch (System.Exception e)
        {
            Debug.LogError($"載入對話數據失敗 {dialogID}: {e.Message}");
        }
        
        return null;
    }
    
    // 🔄 處理對話數據
    void ProcessDialogData(DialogData dialogData)
    {
        // 處理玩家名稱替換
        string playerName = GetPlayerName();
        
        foreach (var plotOption in dialogData.plotOptionsList)
        {
            foreach (var dialogDetail in plotOption.dialogDataDetails)
            {
                // 替換玩家名稱佔位符
                dialogDetail.sentence = dialogDetail.sentence.Replace("pName", playerName);
                
                // 處理其他特殊標記
                ProcessSpecialTags(dialogDetail);
            }
        }
    }
    
    // 🏷️ 處理特殊標記
    void ProcessSpecialTags(DialogDataDetail dialogDetail)
    {
        // 處理動態內容標記
        if (dialogDetail.sentence.Contains("{TIME}"))
        {
            string timeText = GetCurrentTimeText();
            dialogDetail.sentence = dialogDetail.sentence.Replace("{TIME}", timeText);
        }
        
        // 處理數值標記
        if (dialogDetail.sentence.Contains("{FRIENDSHIP}"))
        {
            string friendshipText = GetFriendshipText();
            dialogDetail.sentence = dialogDetail.sentence.Replace("{FRIENDSHIP}", friendshipText);
        }
    }
    
    // 💾 加入緩存
    void AddToCache(string dialogID, DialogData dialogData)
    {
        // 檢查緩存大小限制
        if (dialogCache.Count >= maxCacheSize)
        {
            // 移除最舊的緩存項目
            string oldestKey = cacheQueue.Dequeue();
            dialogCache.Remove(oldestKey);
        }
        
        dialogCache[dialogID] = dialogData;
        cacheQueue.Enqueue(dialogID);
    }
    
    // 🧹 清理緩存
    public void ClearCache()
    {
        dialogCache.Clear();
        cacheQueue.Clear();
    }
    
    // 📊 獲取玩家名稱
    string GetPlayerName()
    {
        return FindObjectOfType<NumericalRecords>()?.playerName ?? "玩家";
    }
    
    // 🕐 獲取當前時間文字
    string GetCurrentTimeText()
    {
        var timeManager = FindObjectOfType<TimeManagerTest>();
        if (timeManager != null)
        {
            return timeManager.GetTimeDescription();
        }
        return "現在";
    }
    
    // 💝 獲取好感度文字
    string GetFriendshipText()
    {
        var numericalRecords = FindObjectOfType<NumericalRecords>();
        if (numericalRecords != null)
        {
            return GetFriendshipDescription(numericalRecords.friendship);
        }
        return "普通";
    }
}
```

### 📈 StoryProgressTracker 劇情進度追蹤器
```csharp
public class StoryProgressTracker : MonoBehaviour
{
    [Header("進度數據")]
    public StoryProgressData progressData;
    
    [Header("進度配置")]
    public StoryProgressConfig progressConfig;
    
    private Dictionary<string, int> storyFlags;
    private Dictionary<string, bool> eventFlags;
    
    void Start()
    {
        InitializeProgressTracker();
    }
    
    // 🚀 初始化進度追蹤器
    void InitializeProgressTracker()
    {
        LoadProgressData();
        InitializeFlags();
        
        // 訂閱相關事件
        EventBus.Instance.Subscribe<DialogCompleteEvent>("DialogComplete", OnDialogComplete);
        EventBus.Instance.Subscribe<ChoiceMadeEvent>("ChoiceMade", OnChoiceMade);
    }
    
    // 📊 載入進度數據
    void LoadProgressData()
    {
        // 從存檔系統載入進度
        var saveManager = FindObjectOfType<SaveDataManager>();
        if (saveManager != null)
        {
            progressData = saveManager.LoadStoryProgress();
        }
        
        if (progressData == null)
        {
            progressData = CreateNewProgressData();
        }
    }
    
    // 🎯 更新劇情進度
    public void UpdateStoryProgress(string storyID, int newProgress)
    {
        if (progressData.storyProgress.ContainsKey(storyID))
        {
            int currentProgress = progressData.storyProgress[storyID];
            if (newProgress > currentProgress)
            {
                progressData.storyProgress[storyID] = newProgress;
                OnProgressUpdated(storyID, newProgress);
            }
        }
        else
        {
            progressData.storyProgress[storyID] = newProgress;
            OnProgressUpdated(storyID, newProgress);
        }
        
        SaveProgressData();
    }
    
    // 🎖️ 設定事件標記
    public void SetEventFlag(string eventID, bool value)
    {
        progressData.eventFlags[eventID] = value;
        
        // 觸發事件標記變更事件
        EventBus.Instance.Publish("EventFlagChanged", new EventFlagChangedEvent
        {
            eventID = eventID,
            newValue = value
        });
        
        SaveProgressData();
    }
    
    // 🔍 檢查進度條件
    public bool CheckProgressCondition(StoryCondition condition)
    {
        switch (condition.type)
        {
            case ConditionType.StoryProgress:
                return GetStoryProgress(condition.storyID) >= condition.requiredValue;
                
            case ConditionType.EventFlag:
                return GetEventFlag(condition.eventID) == condition.requiredBool;
                
            case ConditionType.PlayerStats:
                return CheckPlayerStatsCondition(condition);
                
            case ConditionType.TimeCondition:
                return CheckTimeCondition(condition);
                
            default:
                return true;
        }
    }
    
    // 📊 獲取劇情進度
    public int GetStoryProgress(string storyID)
    {
        return progressData.storyProgress.ContainsKey(storyID) ? 
               progressData.storyProgress[storyID] : 0;
    }
    
    // 🎖️ 獲取事件標記
    public bool GetEventFlag(string eventID)
    {
        return progressData.eventFlags.ContainsKey(eventID) ? 
               progressData.eventFlags[eventID] : false;
    }
    
    // 📡 對話完成事件處理
    void OnDialogComplete(DialogCompleteEvent eventData)
    {
        // 更新對話完成進度
        UpdateStoryProgress(eventData.dialogID, eventData.progressIncrement);
        
        // 檢查並觸發相關事件
        CheckAndTriggerEvents(eventData.dialogID);
    }
    
    // 📡 選擇完成事件處理
    void OnChoiceMade(ChoiceMadeEvent eventData)
    {
        // 記錄選擇結果
        string choiceKey = $"{eventData.dialogID}_choice_{eventData.choiceIndex}";
        SetEventFlag(choiceKey, true);
        
        // 處理選擇後果
        ProcessChoiceConsequences(eventData);
    }
    
    // 💾 保存進度數據
    void SaveProgressData()
    {
        var saveManager = FindObjectOfType<SaveDataManager>();
        if (saveManager != null)
        {
            saveManager.SaveStoryProgress(progressData);
        }
    }
}
```

---

## 🎮 劇情控制層架構

### 🎬 GamePlayingManagerDrama 劇情主控制器
```csharp
public class GamePlayingManagerDrama : MonoBehaviour
{
    [Header("系統組件")]
    public TextBoxDrama textBoxDrama;
    public ActorManagerDrama actorManager;
    public CGDisplay cgDisplay;
    public StoryAudioManager audioManager;
    
    [Header("流程控制")]
    public StoryFlowController flowController;
    public ChoiceSystemManager choiceSystem;
    public StoryStateManager stateManager;
    
    [Header("數據管理")]
    public DialogDataManager dataManager;
    public StoryProgressTracker progressTracker;
    
    [Header("當前狀態")]
    public string currentDialogID;
    public int currentDialogIndex;
    public StoryState currentState = StoryState.Idle;
    
    void Start()
    {
        InitializeDramaManager();
    }
    
    // 🚀 初始化劇情管理器
    void InitializeDramaManager()
    {
        // 初始化各個子系統
        InitializeSubSystems();
        
        // 訂閱事件
        SubscribeToEvents();
        
        // 設定初始狀態
        SetInitialState();
    }
    
    // 🎯 開始劇情播放
    public void StartStoryPlayback(string dialogID, int startIndex = 0)
    {
        if (currentState != StoryState.Idle)
        {
            Debug.LogWarning("劇情系統忙碌中，無法開始新的劇情");
            return;
        }
        
        currentDialogID = dialogID;
        currentDialogIndex = startIndex;
        
        // 載入對話數據
        DialogData dialogData = dataManager.LoadDialogData(dialogID);
        if (dialogData == null)
        {
            Debug.LogError($"無法載入對話數據: {dialogID}");
            return;
        }
        
        // 設定劇情狀態
        stateManager.SetState(StoryState.Playing);
        
        // 初始化劇情播放環境
        InitializeStoryEnvironment(dialogData);
        
        // 開始播放第一段對話
        PlayCurrentDialog();
    }
    
    // 🎭 播放當前對話
    void PlayCurrentDialog()
    {
        DialogData dialogData = dataManager.LoadDialogData(currentDialogID);
        if (dialogData == null || currentDialogIndex >= dialogData.plotOptionsList.Count)
        {
            // 劇情結束
            EndStoryPlayback();
            return;
        }
        
        var currentPlot = dialogData.plotOptionsList[currentDialogIndex];
        
        // 檢查播放條件
        if (!CheckPlayConditions(currentPlot))
        {
            // 跳過這段劇情
            AdvanceToNextDialog();
            return;
        }
        
        // 設定演員狀態
        actorManager.SetupActorsForDialog(currentPlot);
        
        // 設定CG場景
        if (currentPlot.requiresCGDisplay)
        {
            cgDisplay.DisplayCGScene(currentPlot.cgIndex);
        }
        
        // 播放音效
        if (!string.IsNullOrEmpty(currentPlot.bgmName))
        {
            audioManager.PlayBackgroundMusic(currentPlot.bgmName);
        }
        
        // 開始文字顯示
        textBoxDrama.StartTextDisplay(currentPlot);
    }
    
    // ⏭️ 進入下一段對話
    public void AdvanceToNextDialog()
    {
        DialogData dialogData = dataManager.LoadDialogData(currentDialogID);
        
        if (currentDialogIndex < dialogData.plotOptionsList.Count - 1)
        {
            currentDialogIndex++;
            
            // 檢查是否有選擇分支
            var currentPlot = dialogData.plotOptionsList[currentDialogIndex];
            if (currentPlot.hasChoices)
            {
                ShowChoiceOptions(currentPlot);
            }
            else
            {
                PlayCurrentDialog();
            }
        }
        else
        {
            // 劇情結束
            EndStoryPlayback();
        }
    }
    
    // 🔀 顯示選擇選項
    void ShowChoiceOptions(PlotOptions plotOption)
    {
        stateManager.SetState(StoryState.WaitingForChoice);
        choiceSystem.ShowChoices(plotOption.choices, OnChoiceSelected);
    }
    
    // ✅ 選擇完成回調
    void OnChoiceSelected(int choiceIndex)
    {
        // 處理選擇結果
        ProcessChoiceResult(choiceIndex);
        
        // 繼續劇情
        stateManager.SetState(StoryState.Playing);
        AdvanceToNextDialog();
    }
    
    // 🎬 處理選擇結果
    void ProcessChoiceResult(int choiceIndex)
    {
        DialogData dialogData = dataManager.LoadDialogData(currentDialogID);
        var currentPlot = dialogData.plotOptionsList[currentDialogIndex];
        
        if (choiceIndex < currentPlot.choices.Length)
        {
            var selectedChoice = currentPlot.choices[choiceIndex];
            
            // 應用選擇後果
            ApplyChoiceConsequences(selectedChoice);
            
            // 觸發選擇事件
            EventBus.Instance.Publish("ChoiceMade", new ChoiceMadeEvent
            {
                dialogID = currentDialogID,
                choiceIndex = choiceIndex,
                choiceText = selectedChoice.choiceText
            });
        }
    }
    
    // 🎊 應用選擇後果
    void ApplyChoiceConsequences(ChoiceData choiceData)
    {
        // 數值變化
        if (choiceData.statChanges != null)
        {
            var numericalRecords = FindObjectOfType<NumericalRecords>();
            foreach (var statChange in choiceData.statChanges)
            {
                numericalRecords.ModifyStat(statChange.statName, statChange.changeValue);
            }
        }
        
        // 事件標記
        if (!string.IsNullOrEmpty(choiceData.eventFlag))
        {
            progressTracker.SetEventFlag(choiceData.eventFlag, true);
        }
        
        // 劇情分支
        if (!string.IsNullOrEmpty(choiceData.branchDialogID))
        {
            // 跳轉到新的劇情分支
            StartStoryPlayback(choiceData.branchDialogID);
        }
    }
    
    // 🏁 結束劇情播放
    void EndStoryPlayback()
    {
        // 更新劇情進度
        progressTracker.UpdateStoryProgress(currentDialogID, currentDialogIndex + 1);
        
        // 清理劇情環境
        CleanupStoryEnvironment();
        
        // 設定狀態為閒置
        stateManager.SetState(StoryState.Idle);
        
        // 觸發劇情結束事件
        EventBus.Instance.Publish("StoryComplete", new StoryCompleteEvent
        {
            dialogID = currentDialogID,
            completedAt = System.DateTime.Now
        });
        
        // 檢查CG解鎖
        CheckAndUnlockCG();
        
        // 返回主遊戲或切換場景
        HandleStoryCompletion();
    }
    
    // 🖼️ 檢查並解鎖CG
    void CheckAndUnlockCG()
    {
        string eventID = $"story_complete_{currentDialogID}";
        CGUnlockManager.Instance.ProcessEventUnlock(eventID);
    }
    
    // 🔄 處理劇情完成
    void HandleStoryCompletion()
    {
        // 根據劇情類型決定後續行動
        DialogData dialogData = dataManager.LoadDialogData(currentDialogID);
        
        if (dialogData.returnToNurturingMode)
        {
            // 返回養成模式
            SceneManager.LoadScene("NurturingMode");
        }
        else if (!string.IsNullOrEmpty(dialogData.nextSceneName))
        {
            // 載入指定場景
            SceneManager.LoadScene(dialogData.nextSceneName);
        }
        else
        {
            // 默認返回主選單
            SceneManager.LoadScene("MainMenu");
        }
    }
    
    // 🧹 清理劇情環境
    void CleanupStoryEnvironment()
    {
        textBoxDrama.ClearDisplay();
        actorManager.ResetAllActors();
        cgDisplay.HideAllCG();
        audioManager.StopAllAudio();
    }
}
```

---

## 🎨 展示渲染層架構

### 📝 TextBoxDrama 對話文字渲染器
```csharp
public class TextBoxDrama : MonoBehaviour
{
    [Header("UI組件")]
    public Text nameText;
    public Text contentText;
    public Image dialogBackground;
    public CanvasGroup dialogCanvasGroup;
    
    [Header("打字機效果")]
    public float defaultTypeSpeed = 0.05f;
    public AnimationCurve typeSpeedCurve;
    public AudioClip typingSound;
    
    [Header("文字效果")]
    public TextEffectController textEffectController;
    public Color[] characterColors;
    
    private Coroutine typingCoroutine;
    private bool isTyping = false;
    private bool isSkipRequested = false;
    
    // 🎯 開始文字顯示
    public void StartTextDisplay(PlotOptions plotOption)
    {
        if (plotOption.dialogDataDetails.Count == 0)
        {
            Debug.LogWarning("沒有對話內容可顯示");
            return;
        }
        
        // 顯示對話框
        ShowDialogBox();
        
        // 開始顯示對話內容
        StartCoroutine(DisplayDialogSequence(plotOption));
    }
    
    // 🎭 顯示對話序列
    IEnumerator DisplayDialogSequence(PlotOptions plotOption)
    {
        foreach (var dialogDetail in plotOption.dialogDataDetails)
        {
            // 設定角色名稱
            SetCharacterName(dialogDetail.speaker);
            
            // 設定文字顏色
            SetTextColor(dialogDetail.speaker);
            
            // 顯示對話內容
            yield return StartCoroutine(TypewriterEffect(dialogDetail.sentence, dialogDetail.typeSpeed));
            
            // 等待玩家輸入
            yield return StartCoroutine(WaitForPlayerInput());
            
            // 處理特殊效果
            if (dialogDetail.hasSpecialEffect)
            {
                yield return StartCoroutine(PlaySpecialEffect(dialogDetail.effectType));
            }
        }
        
        // 通知對話完成
        NotifyDialogComplete();
    }
    
    // ⌨️ 打字機效果
    IEnumerator TypewriterEffect(string fullText, float customSpeed = -1)
    {
        isTyping = true;
        isSkipRequested = false;
        
        float typeSpeed = customSpeed > 0 ? customSpeed : defaultTypeSpeed;
        contentText.text = "";
        
        for (int i = 0; i < fullText.Length; i++)
        {
            // 檢查跳過請求
            if (isSkipRequested)
            {
                contentText.text = fullText;
                break;
            }
            
            // 添加字符
            contentText.text += fullText[i];
            
            // 播放打字音效
            if (typingSound != null && i % 3 == 0) // 每3個字符播放一次音效
            {
                AudioSource.PlayClipAtPoint(typingSound, transform.position, 0.3f);
            }
            
            // 處理特殊字符
            if (IsSpecialCharacter(fullText[i]))
            {
                yield return new WaitForSeconds(typeSpeed * 2); // 標點符號停頓更久
            }
            else
            {
                float dynamicSpeed = GetDynamicTypeSpeed(i, fullText.Length, typeSpeed);
                yield return new WaitForSeconds(dynamicSpeed);
            }
        }
        
        isTyping = false;
    }
    
    // ⚡ 獲取動態打字速度
    float GetDynamicTypeSpeed(int currentIndex, int totalLength, float baseSpeed)
    {
        float progress = (float)currentIndex / totalLength;
        float speedMultiplier = typeSpeedCurve.Evaluate(progress);
        return baseSpeed * speedMultiplier;
    }
    
    // 👆 等待玩家輸入
    IEnumerator WaitForPlayerInput()
    {
        // 顯示繼續提示
        ShowContinueIndicator(true);
        
        bool inputReceived = false;
        
        while (!inputReceived)
        {
            // 檢查點擊或按鍵輸入
            if (Input.GetMouseButtonDown(0) || Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.Return))
            {
                if (isTyping)
                {
                    // 如果正在打字，則跳過打字效果
                    isSkipRequested = true;
                    yield return new WaitUntil(() => !isTyping);
                }
                else
                {
                    // 繼續下一段對話
                    inputReceived = true;
                }
            }
            
            yield return null;
        }
        
        // 隱藏繼續提示
        ShowContinueIndicator(false);
    }
    
    // 🎨 設定角色名稱
    void SetCharacterName(Speaker speaker)
    {
        string characterName = GetCharacterName(speaker);
        nameText.text = characterName;
        
        // 設定名稱顏色
        Color nameColor = GetCharacterColor(speaker);
        nameText.color = nameColor;
    }
    
    // 🌈 設定文字顏色
    void SetTextColor(Speaker speaker)
    {
        Color textColor = GetCharacterColor(speaker);
        contentText.color = textColor;
    }
    
    // 👥 獲取角色名稱
    string GetCharacterName(Speaker speaker)
    {
        switch (speaker)
        {
            case Speaker.Player:
                return FindObjectOfType<NumericalRecords>()?.playerName ?? "玩家";
            case Speaker.GirlFriend:
                return "由香";
            case Speaker.Chorus:
                return "";
            default:
                return speaker.ToString();
        }
    }
    
    // 🎨 獲取角色顏色
    Color GetCharacterColor(Speaker speaker)
    {
        int colorIndex = (int)speaker;
        if (colorIndex < characterColors.Length)
        {
            return characterColors[colorIndex];
        }
        return Color.white;
    }
    
    // ✨ 播放特殊效果
    IEnumerator PlaySpecialEffect(TextEffectType effectType)
    {
        switch (effectType)
        {
            case TextEffectType.Shake:
                yield return StartCoroutine(textEffectController.ShakeText(contentText, 0.5f));
                break;
                
            case TextEffectType.Fade:
                yield return StartCoroutine(textEffectController.FadeText(contentText, 1.0f));
                break;
                
            case TextEffectType.ColorChange:
                yield return StartCoroutine(textEffectController.ColorChangeText(contentText, Color.red, 0.8f));
                break;
                
            default:
                yield return null;
                break;
        }
    }
    
    // 📢 通知對話完成
    void NotifyDialogComplete()
    {
        EventBus.Instance.Publish("DialogSegmentComplete", new DialogSegmentCompleteEvent
        {
            timestamp = System.DateTime.Now
        });
    }
    
    // 🎭 顯示對話框
    void ShowDialogBox()
    {
        dialogCanvasGroup.alpha = 0;
        gameObject.SetActive(true);
        
        StartCoroutine(FadeInDialogBox());
    }
    
    // 🌅 淡入對話框
    IEnumerator FadeInDialogBox()
    {
        float elapsedTime = 0;
        float fadeTime = 0.3f;
        
        while (elapsedTime < fadeTime)
        {
            elapsedTime += Time.deltaTime;
            dialogCanvasGroup.alpha = Mathf.Clamp01(elapsedTime / fadeTime);
            yield return null;
        }
        
        dialogCanvasGroup.alpha = 1;
    }
    
    // 🧹 清理顯示
    public void ClearDisplay()
    {
        if (typingCoroutine != null)
        {
            StopCoroutine(typingCoroutine);
        }
        
        contentText.text = "";
        nameText.text = "";
        gameObject.SetActive(false);
    }
}
```

---

## 🔗 整合服務層架構

### 💾 SaveSystemIntegration 存檔系統整合
```csharp
public class SaveSystemIntegration : MonoBehaviour
{
    [Header("存檔組件")]
    public SaveDataManager saveManager;
    public StoryProgressTracker progressTracker;
    
    void Start()
    {
        InitializeIntegration();
    }
    
    // 🚀 初始化整合
    void InitializeIntegration()
    {
        // 訂閱劇情系統事件
        EventBus.Instance.Subscribe<StoryCompleteEvent>("StoryComplete", OnStoryComplete);
        EventBus.Instance.Subscribe<ChoiceMadeEvent>("ChoiceMade", OnChoiceMade);
        EventBus.Instance.Subscribe<EventFlagChangedEvent>("EventFlagChanged", OnEventFlagChanged);
    }
    
    // 📚 劇情完成處理
    void OnStoryComplete(StoryCompleteEvent eventData)
    {
        // 自動保存劇情進度
        AutoSaveStoryProgress(eventData);
        
        // 更新存檔中的劇情統計
        UpdateStoryStatistics(eventData);
    }
    
    // 🔀 選擇完成處理
    void OnChoiceMade(ChoiceMadeEvent eventData)
    {
        // 記錄選擇歷史
        RecordChoiceHistory(eventData);
    }
    
    // 🎖️ 事件標記變更處理
    void OnEventFlagChanged(EventFlagChangedEvent eventData)
    {
        // 同步事件標記到存檔
        SyncEventFlagToSave(eventData);
    }
    
    // 💾 自動保存劇情進度
    void AutoSaveStoryProgress(StoryCompleteEvent eventData)
    {
        var currentSave = saveManager.GetCurrentSaveData();
        
        if (currentSave != null)
        {
            // 更新劇情進度記錄
            currentSave.storyProgress[eventData.dialogID] = true;
            currentSave.lastStoryPlayTime = eventData.completedAt;
            
            // 保存到當前存檔槽位
            saveManager.SaveCurrentGame();
        }
    }
}
```

---

## 📊 數據流圖

```
🎭 劇情播放系統數據流
│
📥 劇情觸發
    ↓
🗂️ DialogDataManager.LoadDialogData()
    ↓
📊 StoryProgressTracker.CheckConditions()
    ↓
🎮 GamePlayingManagerDrama.StartStoryPlayback()
    ↓
🎨 TextBoxDrama.StartTextDisplay()
    ↓
👤 ActorManagerDrama.SetupActors()
    ↓
🖼️ CGDisplay.DisplayScene() (如需要)
    ↓
🎵 StoryAudioManager.PlayAudio()
    ↓
👆 等待玩家輸入
    ↓
🔀 ChoiceSystemManager.ProcessChoice() (如有選擇)
    ↓
📈 StoryProgressTracker.UpdateProgress()
    ↓
💾 SaveSystemIntegration.AutoSave()
    ↓
🖼️ CGUnlockIntegration.CheckUnlock()
    ↓
🏁 劇情完成 / 返回遊戲
```

---

## 💬 Claude 使用提示

### 🎯 架構重點
1. **分層設計**: 清晰的職責分離，便於維護和擴展
2. **事件驅動**: 使用EventBus實現組件間解耦通信
3. **數據驅動**: JSON驅動的內容管理，支援熱更新
4. **狀態管理**: 完整的劇情播放狀態控制

### 🔧 開發建議
- **階段一**: 實作ChapterConfigManager和基礎配置系統
- **階段二**: 修改現有對話JSON格式，加入廣義角色類型
- **階段三**: 實作ChapterActorMapper角色映射系統
- **階段四**: 整合語音播放和造型系統
- 確保事件系統的穩定性和錯誤處理
- 注重文字顯示效果和用戶體驗
- 考慮大量對話數據的性能優化

### ⚠️ 注意事項
- **新舊格式兼容**: 確保新版JSON格式與現有系統的兼容性
- **角色映射錯誤處理**: 當映射失敗時的降級機制
- **資源路徑驗證**: 確保配置的資源路徑實際存在
- **語音索引管理**: 正確的語音播放序列和索引追蹤
- JSON文件的版本兼容性處理
- 對話數據的緩存管理
- 劇情分支的複雜度控制
- 存檔系統的數據同步

---

**最後更新**: 2025-07-30  
**版本**: 1.0  
**維護者**: 開發團隊 + Claude AI

> 🎭 **架構亮點**: 劇情播放系統架構採用分層模組化設計，通過JSON驅動的內容管理和事件驅動的流程控制，實現了高度靈活和可擴展的敘事引擎。系統不僅支援複雜的劇情分支和選擇系統，還提供了豐富的視覺和音效體驗！ ✨