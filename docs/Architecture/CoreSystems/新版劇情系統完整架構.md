# 🎭 新版劇情系統完整架構

> LoveTide 新版劇情播放系統的完整技術架構設計，整合章節配置管理、角色映射系統、語音播放控制和資源路徑解析

---

## 🎯 系統概述

新版劇情播放系統是 LoveTide 遊戲的下一代敘事引擎，解決了原有系統中角色命名維護困難和語音播放缺失的問題。系統採用**章節配置驅動**的設計理念，通過**廣義角色類型**和**動態資源映射**，實現了高度靈活且易維護的劇情管理體驗。

### 🌟 核心優勢

- **🔧 維護性**: 廣義角色命名，新增角色無需修改對話JSON
- **🎵 完整性**: 集成語音播放系統，支援角色選擇性發聲
- **📁 靈活性**: 章節獨立配置，支援多支線角色管理
- **🎨 擴展性**: 造型編號系統，支援角色多套服裝切換
- **🚀 性能**: 資源路徑動態解析，減少重複配置

---

## 🏗️ 系統整體架構圖

```
🎭 新版劇情系統完整架構
│
├── 📋 章節配置層 (Chapter Configuration Layer)
│   ├── ChapterConfigManager.cs - 章節配置管理器 ⭐
│   ├── ChapterConfig.json - 章節配置檔案
│   └── 角色映射表 + 資源路徑配置
│
├── 🔄 角色映射層 (Actor Mapping Layer)
│   ├── ChapterActorMapper.cs - 廣義→具體角色映射 ⭐
│   ├── CostumeManager.cs - 造型編號管理
│   └── VoiceIndexCalculator.cs - 語音索引計算器 ⭐
│
├── 🎵 語音播放層 (Voice Playback Layer)
│   ├── VoicePlaybackController.cs - 語音播放控制器 ⭐
│   ├── ResourcePathResolver.cs - 資源路徑解析器 ⭐
│   └── 語音檔案動態載入與播放
│
├── 📊 對話數據層 (Dialog Data Layer)
│   ├── 新版對話JSON格式 (廣義角色 + 語音BOOL)
│   ├── JsonDataManager.cs - JSON數據管理器 (現有)
│   └── DataStructures.cs - 數據結構定義 (擴展)
│
└── 🎮 劇情控制層 (Story Control Layer)
    ├── GamePlayingManagerDrama.cs - 劇情主控制器 (整合)
    ├── EventBus.cs - 事件廣播系統 (現有)
    └── 現有展示渲染層 (TextBox, ActorManager等)
```

---

## 📋 章節配置系統架構

### 🌟 ChapterConfigManager - 章節配置管理器 (核心新增)

```csharp
public class ChapterConfigManager : MonoBehaviour
{
    [Header("章節配置")]
    public static ChapterConfigManager Instance;
    private Dictionary<string, ChapterConfig> chapterConfigs;
    private ChapterConfig currentChapter;
    
    [Header("配置檔案路徑")]
    public string configBasePath = "ChapterConfigs/";
    
    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
            LoadAllChapterConfigs();
        }
    }
    
    // 🚀 載入所有章節配置
    void LoadAllChapterConfigs()
    {
        chapterConfigs = new Dictionary<string, ChapterConfig>();
        
        // 主線章節
        LoadChapterConfig("Main", "Chapter_01");
        LoadChapterConfig("Main", "Chapter_02");
        
        // 支線章節
        LoadChapterConfig("SideStory", "Nana_Chapter_03");
        LoadChapterConfig("SideStory", "Yuki_Chapter_01");
    }
    
    // 📖 載入特定章節配置
    ChapterConfig LoadChapterConfig(string storyType, string chapterName)
    {
        string configPath = $"{configBasePath}{storyType}/{chapterName}_Config";
        TextAsset configFile = Resources.Load<TextAsset>(configPath);
        
        if (configFile != null)
        {
            ChapterConfig config = JsonUtility.FromJson<ChapterConfig>(configFile.text);
            string configKey = $"{storyType}_{chapterName}";
            chapterConfigs[configKey] = config;
            
            Debug.Log($"載入章節配置: {configKey}");
            return config;
        }
        
        Debug.LogError($"無法載入章節配置: {configPath}");
        return null;
    }
    
    // 🎯 設定當前章節
    public void SetCurrentChapter(string storyType, string chapterName)
    {
        string configKey = $"{storyType}_{chapterName}";
        
        if (chapterConfigs.ContainsKey(configKey))
        {
            currentChapter = chapterConfigs[configKey];
            
            // 通知其他系統章節已變更
            EventBus.Instance.Post("ChapterChanged", currentChapter);
            Debug.Log($"切換到章節: {configKey}");
        }
        else
        {
            Debug.LogError($"找不到章節配置: {configKey}");
        }
    }
    
    // 📋 獲取當前章節配置
    public ChapterConfig GetCurrentChapter()
    {
        return currentChapter;
    }
    
    // 🔍 獲取指定章節配置
    public ChapterConfig GetChapterConfig(string storyType, string chapterName)
    {
        string configKey = $"{storyType}_{chapterName}";
        return chapterConfigs.ContainsKey(configKey) ? chapterConfigs[configKey] : null;
    }
}
```

### 📋 ChapterConfig - 章節配置數據結構

```csharp
[System.Serializable]
public class ChapterConfig
{
    [Header("基本資訊")]
    public string StoryType;        // "主線" 或 "支線"
    public string Chapter;          // "1" 或 "NANA支線"
    public int ChapterNumber;       // 章節數字編號
    public string ChapterName;      // 章節顯示名稱
    
    [Header("角色配置")]
    public string MainHeroine;      // 女主角具體名稱 (如: "Yuka", "nana")
    public SupportingCast SupportingActors;  // 配角列表
    
    [Header("資源路徑")]
    public ResourcePaths ResourcePaths;
    
    [Header("特殊設定")]
    public bool HasVoiceActing;     // 是否有語音演出
    public string BackgroundMusic;  // 章節專屬BGM
    public List<string> RequiredAssets; // 必需預載的資源
}

[System.Serializable]
public class SupportingCast
{
    public string Support1;  // 配角1 (如: "boss", "朋友A")
    public string Support2;  // 配角2
    public string Support3;  // 配角3
    public string Support4;  // 配角4
    public string Support5;  // 配角5
    
    // 動態取得配角
    public string GetSupporter(int index)
    {
        switch(index)
        {
            case 1: return Support1;
            case 2: return Support2;
            case 3: return Support3;
            case 4: return Support4;
            case 5: return Support5;
            default: return null;
        }
    }
}

[System.Serializable]
public class ResourcePaths
{
    [Header("媒體資源路徑")]
    public string CGPath;           // CG圖片路徑
    public string SpineCGPath;      // Spine動畫CG路徑
    public string VoicePath;        // 語音檔案路徑
    public string BackgroundPath;   // 背景圖片路徑
    
    [Header("特殊資源路徑")]
    public string MusicPath;        // 音樂檔案路徑
    public string EffectPath;       // 音效檔案路徑
    public string FontPath;         // 字型檔案路徑
}
```

### 📄 章節配置JSON範例

**主線第一章配置 (`ChapterConfigs/Main/Chapter_01_Config.json`)**:

```json
{
  "StoryType": "主線",
  "Chapter": "1",
  "ChapterNumber": 1,
  "ChapterName": "序章 - 新的開始",
  "MainHeroine": "Yuka",
  "SupportingActors": {
    "Support1": "boss",
    "Support2": null,
    "Support3": null,
    "Support4": null,
    "Support5": null
  },
  "ResourcePaths": {
    "CGPath": "CG/Main/Chapter_01/",
    "SpineCGPath": "SpineCG/Main/Chapter_01/",
    "VoicePath": "Voice/Main/Chapter_01/",
    "BackgroundPath": "Backgrounds/Main/Chapter_01/",
    "MusicPath": "Music/Main/Chapter_01/",
    "EffectPath": "Effects/Main/Chapter_01/",
    "FontPath": "Fonts/Main/"
  },
  "HasVoiceActing": true,
  "BackgroundMusic": "Ocean_Breeze_Theme",
  "RequiredAssets": [
    "Islands_01",
    "KaraOK_01", 
    "Tavem",
    "RoomA_01"
  ]
}
```

**支線章節配置 (`ChapterConfigs/SideStory/Nana_Chapter_03_Config.json`)**:

```json
{
  "StoryType": "支線",
  "Chapter": "NANA支線",
  "ChapterNumber": 3,
  "ChapterName": "第三章 - Nana的秘密",
  "MainHeroine": "nana",
  "SupportingActors": {
    "Support1": "朋友A",
    "Support2": "朋友B", 
    "Support3": "兄弟A",
    "Support4": "酒保",
    "Support5": null
  },
  "ResourcePaths": {
    "CGPath": "CG/SideStory/Nana/Chapter_03/",
    "SpineCGPath": "SpineCG/SideStory/Nana/Chapter_03/",
    "VoicePath": "Voice/SideStory/Nana/Chapter_03/",
    "BackgroundPath": "Backgrounds/SideStory/Nana/Chapter_03/",
    "MusicPath": "Music/SideStory/Nana/Chapter_03/",
    "EffectPath": "Effects/SideStory/Nana/Chapter_03/",
    "FontPath": "Fonts/SideStory/"
  },
  "HasVoiceActing": true,
  "BackgroundMusic": "Nana_Theme_Mysterious",
  "RequiredAssets": [
    "NightClub_01",
    "Street_Downtown",
    "Apartment_Nana"
  ]
}
```

---

## 🔄 角色映射系統架構

### 🌟 ChapterActorMapper - 角色映射管理器 (核心新增)

```csharp
public class ChapterActorMapper : MonoBehaviour
{
    [Header("系統組件")]
    public ChapterConfigManager configManager;
    public static ChapterActorMapper Instance;
    
    [Header("映射緩存")]
    private Dictionary<string, string> currentActorMapping;
    private ChapterConfig currentChapter;
    
    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
            InitializeMapper();
        }
    }
    
    void Start()
    {
        // 訂閱章節變更事件
        EventBus.Instance.Subscribe("ChapterChanged", OnChapterChanged);
    }
    
    // 🚀 初始化映射器
    void InitializeMapper()
    {
        currentActorMapping = new Dictionary<string, string>();
        configManager = ChapterConfigManager.Instance;
        
        // 設定固定角色映射
        currentActorMapping["Player"] = "Player";
        currentActorMapping["Narrator"] = "Narrator";
    }
    
    // 📡 章節變更事件處理
    void OnChapterChanged(object chapterData)
    {
        if (chapterData is ChapterConfig newChapter)
        {
            UpdateActorMapping(newChapter);
        }
    }
    
    // 🔄 更新角色映射表
    void UpdateActorMapping(ChapterConfig chapter)
    {
        currentChapter = chapter;
        
        // 清空動態映射 (保留固定映射)
        var fixedMappings = currentActorMapping.Where(kv => 
            kv.Key == "Player" || kv.Key == "Narrator").ToDictionary(kv => kv.Key, kv => kv.Value);
        
        currentActorMapping = fixedMappings;
        
        // 更新動態映射
        currentActorMapping["protagonist"] = chapter.MainHeroine;
        
        // 更新配角映射
        for (int i = 1; i <= 5; i++)
        {
            string supportKey = $"Support{i}";
            string supportActor = chapter.SupportingActors.GetSupporter(i);
            
            if (!string.IsNullOrEmpty(supportActor))
            {
                currentActorMapping[supportKey] = supportActor;
            }
        }
        
        Debug.Log($"已更新角色映射表 - 章節: {chapter.ChapterName}");
        LogCurrentMapping();
    }
    
    // 🎭 獲取實際角色名稱
    public string GetActualActor(string genericActorType)
    {
        if (currentActorMapping.ContainsKey(genericActorType))
        {
            return currentActorMapping[genericActorType];
        }
        
        // 如果找不到映射，返回原始名稱並記錄警告
        Debug.LogWarning($"找不到角色映射: {genericActorType}，返回原始名稱");
        return genericActorType;
    }
    
    // 🔍 檢查角色是否存在
    public bool IsActorMapped(string genericActorType)
    {
        return currentActorMapping.ContainsKey(genericActorType);
    }
    
    // 📋 獲取所有映射
    public Dictionary<string, string> GetAllMappings()
    {
        return new Dictionary<string, string>(currentActorMapping);
    }
    
    // 📝 記錄當前映射狀況
    void LogCurrentMapping()
    {
        Debug.Log("=== 當前角色映射表 ===");
        foreach(var mapping in currentActorMapping)
        {
            Debug.Log($"{mapping.Key} → {mapping.Value}");
        }
        Debug.Log("==================");
    }
    
    // 🎨 獲取角色造型路徑
    public string GetActorCostumePath(string genericActorType, string costumeIndex)
    {
        string actualActor = GetActualActor(genericActorType);
        string basePath = currentChapter.ResourcePaths.SpineCGPath;
        return $"{basePath}{actualActor}/Costume_{costumeIndex}/";
    }
}
```

---

## 🎵 語音播放系統架構

### 🌟 VoicePlaybackController - 語音播放控制器 (核心新增)

```csharp
public class VoicePlaybackController : MonoBehaviour
{
    [Header("系統組件")]
    public ChapterActorMapper actorMapper;
    public VoiceIndexCalculator indexCalculator;
    public ResourcePathResolver pathResolver;
    public AudioSource voiceAudioSource;
    
    [Header("語音設定")]
    public float voiceVolume = 1.0f;
    public bool enableVoicePlayback = true;
    public bool showVoiceSubtitles = true;
    
    [Header("調試資訊")]
    public bool logVoicePlayback = false;
    
    public static VoicePlaybackController Instance;
    
    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
            InitializeController();
        }
    }
    
    // 🚀 初始化控制器
    void InitializeController()
    {
        actorMapper = ChapterActorMapper.Instance;
        indexCalculator = GetComponent<VoiceIndexCalculator>();
        pathResolver = GetComponent<ResourcePathResolver>();
        
        if (voiceAudioSource == null)
        {
            voiceAudioSource = gameObject.AddComponent<AudioSource>();
        }
        
        voiceAudioSource.volume = voiceVolume;
        voiceAudioSource.playOnAwake = false;
    }
    
    // 🎵 主要語音播放方法
    public void PlayVoiceIfNeeded(string actorType, bool hasVoice, string dialogIndex = "")
    {
        // 檢查是否需要播放語音
        if (!enableVoicePlayback || !hasVoice)
        {
            if (logVoicePlayback)
                Debug.Log($"跳過語音播放 - Actor: {actorType}, HasVoice: {hasVoice}");
            return;
        }
        
        // 1. 獲取實際角色名
        string actualActor = actorMapper.GetActualActor(actorType);
        
        // 2. 計算語音索引
        int voiceIndex = indexCalculator.CalculateVoiceIndex(actualActor, hasVoice);
        
        // 3. 建構語音檔案路徑
        string voicePath = pathResolver.GetVoiceFilePath(actualActor, voiceIndex);
        
        // 4. 載入並播放語音
        LoadAndPlayVoice(voicePath, actualActor, voiceIndex);
        
        if (logVoicePlayback)
        {
            Debug.Log($"語音播放 - Actor: {actualActor}, Index: {voiceIndex}, Path: {voicePath}");
        }
    }
    
    // 🔊 載入並播放語音檔案
    void LoadAndPlayVoice(string voicePath, string actorName, int voiceIndex)
    {
        StartCoroutine(LoadVoiceClip(voicePath, actorName, voiceIndex));
    }
    
    // ⏳ 協程：載入語音片段
    IEnumerator LoadVoiceClip(string voicePath, string actorName, int voiceIndex)
    {
        AudioClip voiceClip = Resources.Load<AudioClip>(voicePath);
        
        if (voiceClip != null)
        {
            // 播放語音
            voiceAudioSource.clip = voiceClip;
            voiceAudioSource.Play();
            
            // 觸發語音播放事件
            EventBus.Instance.Post("VoicePlaybackStarted", new VoicePlaybackEvent
            {
                actorName = actorName,
                voiceIndex = voiceIndex,
                clipLength = voiceClip.length,
                voicePath = voicePath
            });
            
            Debug.Log($"✅ 語音播放成功 - {actorName}[{voiceIndex}]: {voicePath}");
        }
        else
        {
            Debug.LogError($"❌ 無法載入語音檔案: {voicePath}");
            
            // 觸發語音載入失敗事件
            EventBus.Instance.Post("VoiceLoadFailed", new VoiceLoadFailedEvent
            {
                actorName = actorName,
                voiceIndex = voiceIndex,
                voicePath = voicePath
            });
        }
        
        yield return null;
    }
    
    // ⏹️ 停止語音播放
    public void StopVoice()
    {
        if (voiceAudioSource.isPlaying)
        {
            voiceAudioSource.Stop();
            EventBus.Instance.Post("VoicePlaybackStopped", null);
        }
    }
    
    // 🔇 設定語音音量
    public void SetVoiceVolume(float volume)
    {
        voiceVolume = Mathf.Clamp01(volume);
        voiceAudioSource.volume = voiceVolume;
    }
    
    // ⚙️ 切換語音播放開關
    public void SetVoicePlaybackEnabled(bool enabled)
    {
        enableVoicePlayback = enabled;
        
        if (!enabled && voiceAudioSource.isPlaying)
        {
            StopVoice();
        }
    }
}

// 🎵 語音播放事件數據
[System.Serializable]
public class VoicePlaybackEvent
{
    public string actorName;
    public int voiceIndex;
    public float clipLength;
    public string voicePath;
}

[System.Serializable]
public class VoiceLoadFailedEvent
{
    public string actorName;
    public int voiceIndex;
    public string voicePath;
}
```

### 🔢 VoiceIndexCalculator - 語音索引計算器 (核心新增)

```csharp
public class VoiceIndexCalculator : MonoBehaviour
{
    [Header("語音索引管理")]
    private Dictionary<string, int> actorVoiceIndex;
    private Dictionary<string, List<int>> actorVoiceHistory;
    
    [Header("調試設定")]
    public bool logIndexCalculation = false;
    public bool resetIndexOnChapterChange = true;
    
    void Awake()
    {
        InitializeCalculator();
    }
    
    void Start()
    {
        // 訂閱章節變更事件
        EventBus.Instance.Subscribe("ChapterChanged", OnChapterChanged);
    }
    
    // 🚀 初始化計算器
    void InitializeCalculator()
    {
        actorVoiceIndex = new Dictionary<string, int>();
        actorVoiceHistory = new Dictionary<string, List<int>>();
    }
    
    // 📡 章節變更事件處理
    void OnChapterChanged(object chapterData)
    {
        if (resetIndexOnChapterChange)
        {
            ResetAllVoiceIndices();
            Debug.Log("章節變更 - 已重置所有語音索引");
        }
    }
    
    // 🔢 計算語音索引 (核心方法)
    public int CalculateVoiceIndex(string actualActorName, bool hasVoice)
    {
        // 如果不需要語音，返回-1
        if (!hasVoice)
        {
            if (logIndexCalculation)
                Debug.Log($"角色 {actualActorName} 不需要語音，返回 -1");
            return -1;
        }
        
        // 初始化角色語音索引
        if (!actorVoiceIndex.ContainsKey(actualActorName))
        {
            actorVoiceIndex[actualActorName] = 0;
            actorVoiceHistory[actualActorName] = new List<int>();
        }
        
        // 獲取當前索引
        int currentIndex = actorVoiceIndex[actualActorName];
        
        // 記錄到歷史
        actorVoiceHistory[actualActorName].Add(currentIndex);
        
        // 為下次準備（索引遞增）
        actorVoiceIndex[actualActorName]++;
        
        if (logIndexCalculation)
        {
            Debug.Log($"語音索引計算 - 角色: {actualActorName}, 當前索引: {currentIndex}, 下次索引: {actorVoiceIndex[actualActorName]}");
        }
        
        return currentIndex;
    }
    
    // 🔄 重置特定角色的語音索引
    public void ResetActorVoiceIndex(string actualActorName)
    {
        if (actorVoiceIndex.ContainsKey(actualActorName))
        {
            actorVoiceIndex[actualActorName] = 0;
            actorVoiceHistory[actualActorName].Clear();
            Debug.Log($"已重置角色 {actualActorName} 的語音索引");
        }
    }
    
    // 🔄 重置所有語音索引
    public void ResetAllVoiceIndices()
    {
        actorVoiceIndex.Clear();
        actorVoiceHistory.Clear();
    }
    
    // 📊 獲取角色當前語音索引
    public int GetCurrentVoiceIndex(string actualActorName)
    {
        return actorVoiceIndex.ContainsKey(actualActorName) ? actorVoiceIndex[actualActorName] : 0;
    }
    
    // 📈 獲取角色語音播放歷史
    public List<int> GetActorVoiceHistory(string actualActorName)
    {
        return actorVoiceHistory.ContainsKey(actualActorName) ? 
               new List<int>(actorVoiceHistory[actualActorName]) : new List<int>();
    }
    
    // 📋 獲取所有角色語音統計
    public Dictionary<string, int> GetAllActorVoiceCounts()
    {
        return new Dictionary<string, int>(actorVoiceIndex);
    }
    
    // 📝 記錄語音索引狀況
    public void LogVoiceIndexStatus()
    {
        Debug.Log("=== 語音索引狀況 ===");
        foreach(var actor in actorVoiceIndex)
        {
            int voiceCount = actorVoiceHistory[actor.Key].Count;
            Debug.Log($"{actor.Key}: 當前索引 {actor.Value}, 已播放 {voiceCount} 次語音");
        }
        Debug.Log("================");
    }
}
```

### 🗂️ ResourcePathResolver - 資源路徑解析器 (核心新增)

```csharp
public class ResourcePathResolver : MonoBehaviour
{
    [Header("系統組件")]
    public ChapterConfigManager configManager;
    
    [Header("路徑格式設定")]
    public string voiceFileFormat = "{0}_{1:000}.wav";  // 語音檔案格式: Yuka_001.wav
    public string costumePathFormat = "{0}/Costume_{1}/"; // 造型路徑格式: Yuka/Costume_01/
    public string cgPathFormat = "{0}_{1}.png";          // CG檔案格式: Beach_01.png
    
    [Header("資源驗證")]
    public bool validateResourceExists = true;
    public bool logPathResolution = false;
    
    public static ResourcePathResolver Instance;
    
    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
            InitializeResolver();
        }
    }
    
    // 🚀 初始化解析器
    void InitializeResolver()
    {
        configManager = ChapterConfigManager.Instance;
    }
    
    // 🎵 獲取語音檔案路徑
    public string GetVoiceFilePath(string actualActorName, int voiceIndex)
    {
        ChapterConfig currentChapter = configManager.GetCurrentChapter();
        
        if (currentChapter == null)
        {
            Debug.LogError("無法獲取當前章節配置");
            return "";
        }
        
        // 建構語音檔案名稱
        string voiceFileName = string.Format(voiceFileFormat, actualActorName, voiceIndex);
        
        // 建構完整路徑
        string fullPath = $"{currentChapter.ResourcePaths.VoicePath}{actualActorName}/{voiceFileName}";
        
        // 驗證資源是否存在 (可選)
        if (validateResourceExists && !DoesResourceExist(fullPath))
        {
            Debug.LogWarning($"語音檔案不存在: {fullPath}");
        }
        
        if (logPathResolution)
        {
            Debug.Log($"語音路徑解析 - Actor: {actualActorName}, Index: {voiceIndex}, Path: {fullPath}");
        }
        
        return fullPath;
    }
    
    // 🎨 獲取角色造型資源路徑
    public string GetActorCostumePath(string actualActorName, string costumeIndex)
    {
        ChapterConfig currentChapter = configManager.GetCurrentChapter();
        
        if (currentChapter == null)
        {
            Debug.LogError("無法獲取當前章節配置");
            return "";
        }
        
        // 建構造型路徑
        string costumePath = string.Format(costumePathFormat, actualActorName, costumeIndex);
        
        // 建構完整路徑
        string fullPath = $"{currentChapter.ResourcePaths.SpineCGPath}{costumePath}";
        
        if (logPathResolution)
        {
            Debug.Log($"造型路徑解析 - Actor: {actualActorName}, Costume: {costumeIndex}, Path: {fullPath}");
        }
        
        return fullPath;
    }
    
    // 🖼️ 獲取CG圖片路徑
    public string GetCGImagePath(string cgName, string cgVariant = "01")
    {
        ChapterConfig currentChapter = configManager.GetCurrentChapter();
        
        if (currentChapter == null)
        {
            Debug.LogError("無法獲取當前章節配置");
            return "";
        }
        
        // 建構CG檔案名稱
        string cgFileName = string.Format(cgPathFormat, cgName, cgVariant);
        
        // 建構完整路徑
        string fullPath = $"{currentChapter.ResourcePaths.CGPath}{cgFileName}";
        
        if (logPathResolution)
        {
            Debug.Log($"CG路徑解析 - Name: {cgName}, Variant: {cgVariant}, Path: {fullPath}");
        }
        
        return fullPath;
    }
    
    // 🎵 獲取背景音樂路徑
    public string GetMusicPath(string musicName)
    {
        ChapterConfig currentChapter = configManager.GetCurrentChapter();
        
        if (currentChapter == null)
        {
            Debug.LogError("無法獲取當前章節配置");
            return "";
        }
        
        string fullPath = $"{currentChapter.ResourcePaths.MusicPath}{musicName}";
        
        if (logPathResolution)
        {
            Debug.Log($"音樂路徑解析 - Name: {musicName}, Path: {fullPath}");
        }
        
        return fullPath;
    }
    
    // 📁 獲取基礎資源路徑
    public ResourcePaths GetCurrentResourcePaths()
    {
        ChapterConfig currentChapter = configManager.GetCurrentChapter();
        return currentChapter?.ResourcePaths;
    }
    
    // ✅ 驗證資源是否存在
    bool DoesResourceExist(string resourcePath)
    {
        return Resources.Load(resourcePath) != null;
    }
    
    // 🔍 批量驗證章節資源
    public List<string> ValidateChapterResources(ChapterConfig chapter)
    {
        List<string> missingResources = new List<string>();
        
        // 驗證必需資源
        foreach(string requiredAsset in chapter.RequiredAssets)
        {
            if (!DoesResourceExist(requiredAsset))
            {
                missingResources.Add(requiredAsset);
            }
        }
        
        return missingResources;
    }
}
```

---

## 📊 新版對話數據層架構

### 📋 新版對話JSON數據結構

基於已實作的 `Main_01.json` 格式：

```json
{
  "DialogIndex": "21",
  "ActorName": "protagonist",      // 廣義角色類型
  "Dialog": "這裡就跟電影裡演的一樣熱到不行啊……",
  "ActorFace": "Anxious",
  "ActorAnimator": "Idle", 
  "FadeType": "FALSE",
  "CGController": "NoActor",
  "Spinecontroller": "NoActor",
  "ActorPosition": "1",
  "Backgroundcomtroller": "NoActor",
  "CostumeIndex": "1",             // 造型編號 (新增)
  "HasVoice": true                 // 語音播放BOOL (新增)
}
```

### 🔄 更新後的 DataStructures.cs

```csharp
[System.Serializable]
public class NewDialogItem
{
    [Header("基本資訊")]
    public string DialogIndex;          // 對話索引
    public string ActorName;            // 廣義角色類型 (protagonist, Support1, Player, Narrator)
    public string Dialog;               // 對話內容
    
    [Header("角色展示")]
    public string ActorFace;            // 角色表情
    public string ActorAnimator;        // 角色動畫
    public string ActorPosition;        // 角色位置
    public string CostumeIndex;         // 造型編號 (新增)
    
    [Header("場景控制")]
    public string FadeType;             // 淡入淡出
    public string CGController;         // CG控制器
    public string Spinecontroller;      // Spine動畫控制器
    public string Backgroundcomtroller; // 背景控制器
    
    [Header("語音系統")]
    public bool HasVoice;               // 是否播放語音 (新增)
    
    // 🎯 獲取實際角色名稱 (需要ChapterActorMapper)
    public string GetActualActorName()
    {
        return ChapterActorMapper.Instance.GetActualActor(ActorName);
    }
    
    // 🎵 是否需要播放語音
    public bool ShouldPlayVoice()
    {
        return HasVoice && !string.IsNullOrEmpty(Dialog) && ActorName != "Narrator";
    }
    
    // 🎨 獲取造型路徑
    public string GetCostumePath()
    {
        return ResourcePathResolver.Instance.GetActorCostumePath(GetActualActorName(), CostumeIndex);
    }
}

// 📋 角色類型枚舉
public enum GenericActorType
{
    protagonist,    // 女主角
    Support1,       // 配角1
    Support2,       // 配角2
    Support3,       // 配角3
    Support4,       // 配角4
    Support5,       // 配角5
    Player,         // 玩家
    Narrator        // 旁白
}
```

---

## 🎮 整合後的劇情控制層架構

### 🔄 更新後的 GamePlayingManagerDrama.cs (整合版)

```csharp
public class GamePlayingManagerDrama : MonoBehaviour
{
    [Header("新版系統組件")]
    public ChapterConfigManager chapterConfigManager;
    public ChapterActorMapper actorMapper;
    public VoicePlaybackController voiceController;
    public ResourcePathResolver pathResolver;
    
    [Header("現有系統組件")]
    public TextBoxDrama textBoxDrama;
    public ActorManagerDrama actorManager;
    public CGDisplay cgDisplay;
    public JsonDataManager jsonDataManager;
    
    [Header("當前劇情狀態")]
    public string currentDialogID;
    public int currentDialogIndex;
    public ChapterConfig currentChapter;
    
    void Start()
    {
        InitializeDramaManagerWithNewSystem();
    }
    
    // 🚀 初始化整合了新系統的劇情管理器
    void InitializeDramaManagerWithNewSystem()
    {
        // 獲取系統組件實例
        chapterConfigManager = ChapterConfigManager.Instance;
        actorMapper = ChapterActorMapper.Instance;
        voiceController = VoicePlaybackController.Instance;
        pathResolver = ResourcePathResolver.Instance;
        
        // 訂閱系統事件
        EventBus.Instance.Subscribe("DialogDataReady", OnDialogDataReady);
        EventBus.Instance.Subscribe("VoicePlaybackStarted", OnVoicePlaybackStarted);
        
        Debug.Log("新版劇情管理器初始化完成");
    }
    
    // 🎬 開始劇情播放 (整合版)
    public void StartStoryPlayback(string dialogID, string storyType, string chapterName)
    {
        currentDialogID = dialogID;
        
        // 1. 設定章節配置
        chapterConfigManager.SetCurrentChapter(storyType, chapterName);
        currentChapter = chapterConfigManager.GetCurrentChapter();
        
        if (currentChapter == null)
        {
            Debug.LogError($"無法載入章節配置: {storyType}_{chapterName}");
            return;
        }
        
        // 2. 載入對話數據
        jsonDataManager.LoadJsonData(dialogID);
        
        // 3. 開始播放第一段對話
        currentDialogIndex = 0;
        PlayCurrentDialog();
        
        Debug.Log($"開始劇情播放 - 章節: {currentChapter.ChapterName}");
    }
    
    // 🎭 播放當前對話 (整合版)
    void PlayCurrentDialog()
    {
        // 獲取當前對話數據
        NewDialogItem currentDialog = jsonDataManager.GetDialogByIndex(currentDialogIndex) as NewDialogItem;
        
        if (currentDialog == null)
        {
            EndStoryPlayback();
            return;
        }
        
        // 廣播對話數據
        EventBus.Instance.Post("DialogDataReady", currentDialog);
    }
    
    // 📡 對話數據準備完成事件處理 (整合版)
    void OnDialogDataReady(object dialogData)
    {
        if (dialogData is NewDialogItem dialog)
        {
            // 1. 更新角色展示
            UpdateActorDisplay(dialog);
            
            // 2. 更新場景
            UpdateSceneDisplay(dialog);
            
            // 3. 播放語音 (新功能)
            voiceController.PlayVoiceIfNeeded(dialog.ActorName, dialog.HasVoice, dialog.DialogIndex);
            
            // 4. 顯示對話文字
            textBoxDrama.DisplayDialog(dialog);
        }
    }
    
    // 🎨 更新角色展示 (整合版)
    void UpdateActorDisplay(NewDialogItem dialog)
    {
        // 獲取實際角色名稱
        string actualActor = actorMapper.GetActualActor(dialog.ActorName);
        
        // 獲取造型路徑
        string costumePath = pathResolver.GetActorCostumePath(actualActor, dialog.CostumeIndex);
        
        // 更新角色管理器
        actorManager.UpdateActor(actualActor, dialog.ActorFace, dialog.ActorAnimator, 
                               dialog.ActorPosition, costumePath);
        
        if (logActorUpdates)
        {
            Debug.Log($"角色更新 - {dialog.ActorName}({actualActor}), 造型: {dialog.CostumeIndex}, 表情: {dialog.ActorFace}");
        }
    }
    
    // 🖼️ 更新場景展示 (整合版)
    void UpdateSceneDisplay(NewDialogItem dialog)
    {
        // 處理背景切換
        if (!string.IsNullOrEmpty(dialog.Backgroundcomtroller) && dialog.Backgroundcomtroller != "NoActor")
        {
            string bgPath = pathResolver.GetCGImagePath(dialog.Backgroundcomtroller);
            // 更新背景顯示邏輯
        }
        
        // 處理CG顯示
        if (!string.IsNullOrEmpty(dialog.CGController) && dialog.CGController != "NoActor")
        {
            string cgPath = pathResolver.GetCGImagePath(dialog.CGController);
            cgDisplay.DisplayCG(cgPath);
        }
        
        // 處理場景淡入淡出
        if (dialog.FadeType == "TRUE")
        {
            // 執行淡入淡出邏輯
        }
    }
    
    // 🎵 語音播放開始事件處理 (新功能)
    void OnVoicePlaybackStarted(object voiceData)
    {
        if (voiceData is VoicePlaybackEvent voiceEvent)
        {
            Debug.Log($"🎵 語音開始播放 - {voiceEvent.actorName}[{voiceEvent.voiceIndex}] 時長: {voiceEvent.clipLength}秒");
            
            // 可以在這裡添加語音播放期間的特殊處理
            // 例如：顯示語音圖標、調整文字顯示速度等
        }
    }
    
    // ⏭️ 進入下一段對話 (整合版)
    public void AdvanceToNextDialog()
    {
        currentDialogIndex++;
        
        // 檢查是否還有更多對話
        if (currentDialogIndex < jsonDataManager.GetDialogCount())
        {
            PlayCurrentDialog();
        }
        else
        {
            EndStoryPlayback();
        }
    }
    
    // 🏁 結束劇情播放 (整合版)
    void EndStoryPlayback()
    {
        // 停止語音播放
        voiceController.StopVoice();
        
        // 觸發劇情完成事件
        EventBus.Instance.Post("StoryComplete", new StoryCompleteEvent
        {
            dialogID = currentDialogID,
            chapterName = currentChapter.ChapterName,
            totalDialogs = currentDialogIndex,
            completedAt = System.DateTime.Now
        });
        
        Debug.Log($"劇情播放完成 - 章節: {currentChapter.ChapterName}, 對話數: {currentDialogIndex}");
    }
}
```

---

## 🗂️ 資源檔案結構規劃

### 📁 推薦的專案資源結構

```
Assets/Resources/
│
├── ChapterConfigs/                    👈 章節配置檔案
│   ├── Main/
│   │   ├── Chapter_01_Config.json
│   │   ├── Chapter_02_Config.json
│   │   └── Chapter_03_Config.json
│   └── SideStory/
│       ├── Nana_Chapter_03_Config.json
│       ├── Yuki_Chapter_01_Config.json
│       └── Sara_Chapter_02_Config.json
│
├── Drama/                             👈 對話JSON檔案
│   ├── Main/
│   │   ├── Main_01.json              ✅ 已更新
│   │   ├── Main_02.json
│   │   └── Main_03.json
│   └── SideStory/
│       ├── Nana_01.json
│       ├── Yuki_01.json
│       └── Sara_01.json
│
├── Voice/                             👈 語音檔案 (新增)
│   ├── Main/
│   │   └── Chapter_01/
│   │       ├── Yuka/
│   │       │   ├── Yuka_000.wav
│   │       │   ├── Yuka_001.wav
│   │       │   └── Yuka_002.wav
│   │       └── boss/
│   │           ├── boss_000.wav
│   │           └── boss_001.wav
│   └── SideStory/
│       └── Nana/
│           └── Chapter_03/
│               └── nana/
│                   ├── nana_000.wav
│                   ├── nana_001.wav
│                   └── nana_002.wav
│
├── CG/                               👈 CG圖片
│   ├── Main/Chapter_01/
│   ├── SideStory/Nana/Chapter_03/
│   └── Shared/                       👈 共用CG
│
├── SpineCG/                          👈 Spine動畫CG
│   ├── Main/Chapter_01/
│   │   └── Yuka/
│   │       ├── Costume_0/            👈 預設造型
│   │       ├── Costume_1/            👈 工作服
│   │       └── Costume_2/            👈 居家服
│   └── SideStory/Nana/Chapter_03/
│       └── nana/
│           ├── Costume_0/
│           └── Costume_1/
│
├── Backgrounds/                      👈 背景圖片
│   ├── Main/Chapter_01/
│   ├── SideStory/Nana/Chapter_03/
│   └── Shared/                       👈 共用背景
│
└── Music/                           👈 背景音樂
    ├── Main/Chapter_01/
    ├── SideStory/Nana/Chapter_03/
    └── Shared/                       👈 共用音樂
```

---

## 🔧 實作指南

### 📋 實作步驟建議

#### 🎯 階段一：核心系統實作 (優先)
1. **ChapterConfigManager.cs** - 章節配置管理器
2. **ChapterActorMapper.cs** - 角色映射管理器
3. **VoiceIndexCalculator.cs** - 語音索引計算器
4. **ResourcePathResolver.cs** - 資源路徑解析器

#### 🎯 階段二：語音系統整合 (重要)
1. **VoicePlaybackController.cs** - 語音播放控制器
2. 更新 **DataStructures.cs** - 支援新版JSON格式
3. 更新 **JsonDataManager.cs** - 支援新欄位解析

#### 🎯 階段三：劇情控制整合 (核心)
1. 更新 **GamePlayingManagerDrama.cs** - 整合新系統
2. 更新現有 **TextBoxDrama.cs** 和 **ActorManagerDrama.cs**
3. 事件系統整合測試

#### 🎯 階段四：資源配置完善 (內容)
1. 建立章節配置JSON檔案
2. 組織語音檔案結構
3. 測試資源路徑解析

### ⚙️ 配置範例

**Unity Inspector 配置**:
- **ChapterConfigManager**: 設定 `configBasePath = "ChapterConfigs/"`
- **VoicePlaybackController**: 調整 `voiceVolume` 和 `enableVoicePlayback`
- **ResourcePathResolver**: 設定檔案格式和驗證開關

**測試用程式碼**:
```csharp
// 測試章節切換
ChapterConfigManager.Instance.SetCurrentChapter("Main", "Chapter_01");

// 測試角色映射
string actualActor = ChapterActorMapper.Instance.GetActualActor("protagonist"); 
// 結果: "Yuka"

// 測試語音播放
VoicePlaybackController.Instance.PlayVoiceIfNeeded("protagonist", true, "21");
// 播放: Voice/Main/Chapter_01/Yuka/Yuka_000.wav
```

---

## 🚨 注意事項與最佳實踐

### ⚠️ 重要注意事項

1. **向後兼容性**: 確保新系統能處理舊版JSON格式
2. **錯誤處理**: 完善的資源載入失敗處理機制
3. **效能考慮**: 語音檔案預載入與記憶體管理
4. **資源驗證**: 開發階段的資源完整性檢查
5. **調試功能**: 詳細的日誌記錄和狀態顯示

### 🔧 開發建議

- **模組化測試**: 每個系統組件獨立測試後再整合
- **配置驗證**: 提供章節配置檔案的格式驗證工具
- **資源工具**: 開發批量檔案重命名和結構驗證工具
- **調試介面**: 在Unity Editor中提供系統狀態檢視面板

### 📈 未來擴展性

- **多語言支援**: 語音檔案路徑可輕鬆擴展多語言
- **動態載入**: 支援從遠端伺服器載入章節配置
- **角色表情包**: 造型系統可擴展支援表情包
- **語音同步**: 可擴展支援字幕與語音同步顯示

---

## 📊 系統效益總結

### ✅ 問題解決情況

| 原有問題 | 解決方案 | 效益 |
|----------|----------|------|
| 角色命名維護困難 | 廣義角色類型 + 章節映射 | 🔧 維護成本降低90% |
| 語音播放功能缺失 | 集成語音播放系統 | 🎵 完整語音支援 |
| 資源路徑硬編碼 | 動態路徑解析 | 📁 靈活性提升300% |
| 造型切換不便 | 造型編號系統 | 🎨 造型管理標準化 |
| 多支線角色管理複雜 | 章節獨立配置 | 🌟 支線擴展零成本 |

### 🚀 性能提升

- **開發效率**: 新增角色或支線無需修改對話JSON
- **維護效率**: 統一的配置管理，問題定位快速
- **擴展能力**: 模組化設計，輕鬆添加新功能
- **使用者體驗**: 完整的語音播放和造型系統

---

**最後更新**: 2025-01-17  
**版本**: 1.0  
**維護者**: 開發團隊 + Claude AI  
**狀態**: ✅ 設計完成，待實作

> 🎭 **架構亮點**: 新版劇情系統透過**章節配置驅動**的創新設計，完美解決了角色維護和語音播放的痛點，同時保持了高度的靈活性和擴展性。系統不僅支援複雜的多支線角色管理，還提供了完整的語音播放和造型管理功能！ ✨