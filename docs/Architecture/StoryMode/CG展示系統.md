# ğŸ–¼ï¸ CGå±•ç¤ºç³»çµ±æ¶æ§‹

> LoveTide åŠ‡æƒ…æ¨¡å¼çš„CGå ´æ™¯å±•ç¤ºã€èƒŒæ™¯ç®¡ç†å’Œè¦–è¦ºæ•ˆæœæ¶æ§‹è¨­è¨ˆ

---

## ğŸ¯ æ¦‚è¿°

CGå±•ç¤ºç³»çµ±è² è²¬ç®¡ç† LoveTide åŠ‡æƒ…æ¨¡å¼ä¸­çš„æ‰€æœ‰è¦–è¦ºå ´æ™¯å±•ç¤ºï¼ŒåŒ…æ‹¬èƒŒæ™¯åœ–ç‰‡åˆ‡æ›ã€CGå ´æ™¯ç®¡ç†ã€è¦–è¦ºæ•ˆæœè™•ç†å’Œå ´æ™¯è½‰æ›å‹•ç•«ã€‚ç³»çµ±èˆ‡å°è©±ç³»çµ±ç·Šå¯†æ•´åˆï¼Œæä¾›æ²‰æµ¸å¼çš„è¦–è¦ºé«”é©—ã€‚

---

## âš ï¸ é‡è¦æ¶æ§‹èªªæ˜

### ğŸš¨ **æ¼”å“¡ç³»çµ±æ”¹å‹•é€šçŸ¥**
> âš ï¸ **æ³¨æ„**: æœ¬æ–‡æª”æè¿°çš„CGèˆ‡æ¼”å“¡æ•´åˆéƒ¨åˆ†å°‡éš¨è‘—**æ¼”å“¡ç³»çµ±å¤§æ”¹å‹•**è€Œéœ€è¦èª¿æ•´ã€‚å¯¦éš›å¯¦ä½œæ™‚è«‹åƒè€ƒæœ€æ–°çš„æ¼”å“¡ç³»çµ±æ¶æ§‹ã€‚

### ğŸ“‹ CGç³»çµ±ç‰¹è‰²
- **éœæ…‹ç«‹ç¹ªå±•ç¤º**: ä¸åŒè§’è‰²çš„ç«‹ç¹ªåœ–ç‰‡ç®¡ç†
- **èƒŒæ™¯å ´æ™¯åˆ‡æ›**: å¤šç¨®å ´æ™¯èƒŒæ™¯çš„å‹•æ…‹è¼‰å…¥
- **CGç‰¹æ®Šå ´æ™¯**: é‡è¦åŠ‡æƒ…ç¯€é»çš„å°ˆç”¨CG
- **è¦–è¦ºæ•ˆæœ**: æ·¡å…¥æ·¡å‡ºã€è½‰å ´æ•ˆæœç­‰

---

## ğŸ—ï¸ CGå±•ç¤ºç³»çµ±æ¶æ§‹

### ğŸ“Š æ ¸å¿ƒç³»çµ±çµæ§‹
```
ğŸ–¼ï¸ CGå±•ç¤ºç³»çµ±
â”‚
â”œâ”€â”€ ğŸ¨ CGDisplay (CGé¡¯ç¤ºç®¡ç†å™¨)
â”‚   â”œâ”€â”€ èƒŒæ™¯åœ–ç‰‡ç®¡ç†
â”‚   â”œâ”€â”€ CGå ´æ™¯åˆ‡æ›
â”‚   â”œâ”€â”€ ç«‹ç¹ªé¡¯ç¤ºæ§åˆ¶
â”‚   â””â”€â”€ è¦–è¦ºæ•ˆæœè™•ç†
â”‚
â”œâ”€â”€ ğŸ–¼ï¸ BackgroundManager (èƒŒæ™¯ç®¡ç†å™¨)
â”‚   â”œâ”€â”€ å ´æ™¯èƒŒæ™¯è¼‰å…¥
â”‚   â”œâ”€â”€ èƒŒæ™¯åœ–ç‰‡å¿«å–
â”‚   â”œâ”€â”€ å ´æ™¯é è¼‰å…¥
â”‚   â””â”€â”€ èƒŒæ™¯åˆ‡æ›æ•ˆæœ
â”‚
â”œâ”€â”€ ğŸ­ CGActorIntegration (CGæ¼”å“¡æ•´åˆ)
â”‚   â”œâ”€â”€ ç«‹ç¹ªèˆ‡CGé…åˆ
â”‚   â”œâ”€â”€ è§’è‰²å®šä½ç®¡ç†
â”‚   â”œâ”€â”€ è¡¨æƒ…èˆ‡å ´æ™¯åŒæ­¥
â”‚   â””â”€â”€ æ¼”å“¡é¡¯ç¤ºå„ªå…ˆç´š
â”‚
â””â”€â”€ âœ¨ VisualEffects (è¦–è¦ºæ•ˆæœ)
    â”œâ”€â”€ æ·¡å…¥æ·¡å‡ºæ•ˆæœ
    â”œâ”€â”€ å ´æ™¯è½‰æ›å‹•ç•«
    â”œâ”€â”€ ç‰¹æ®Šè¦–è¦ºæ•ˆæœ
    â””â”€â”€ UIå…ƒç´ å‹•ç•«
```

---

## ğŸ¨ CGDisplay æ ¸å¿ƒå¯¦ç¾

### ğŸ”§ CGé¡¯ç¤ºç®¡ç†å™¨
```csharp
public class CGDisplay : MonoBehaviour
{
    [Header("CGè³‡æº")]
    public Image backgroundImage;           // èƒŒæ™¯åœ–ç‰‡é¡¯ç¤º
    public Image[] cgImages;               // CGåœ–ç‰‡é™£åˆ—
    public Sprite[] backgroundSprites;     // èƒŒæ™¯åœ–ç‰‡è³‡æº
    
    [Header("é¡¯ç¤ºæ§åˆ¶")]
    public bool isShowingCG = false;
    public int currentCGIndex = -1;
    public int currentBackgroundIndex = 0;
    
    [Header("æ•ˆæœè¨­å®š")]
    public float fadeSpeed = 1.0f;
    public AnimationCurve fadeCurve;
    
    // ğŸ–¼ï¸ é¡¯ç¤ºèƒŒæ™¯åœ–ç‰‡
    public void DisplayBackGroundChick(int backgroundIndex)
    {
        if (backgroundIndex >= 0 && backgroundIndex < backgroundSprites.Length)
        {
            StartCoroutine(FadeToBackground(backgroundSprites[backgroundIndex]));
            currentBackgroundIndex = backgroundIndex;
            Debug.Log($"åˆ‡æ›èƒŒæ™¯: {backgroundIndex}");
        }
        else
        {
            Debug.LogWarning($"èƒŒæ™¯ç´¢å¼•è¶…å‡ºç¯„åœ: {backgroundIndex}");
        }
    }
    
    // ğŸ­ é¡¯ç¤ºCGå ´æ™¯
    public void DisplayCGScene(int cgIndex)
    {
        if (cgIndex >= 0 && cgIndex < cgImages.Length)
        {
            StartCoroutine(ShowCGWithEffect(cgIndex));
            currentCGIndex = cgIndex;
            isShowingCG = true;
            Debug.Log($"é¡¯ç¤ºCG: {cgIndex}");
        }
        else
        {
            Debug.LogWarning($"CGç´¢å¼•è¶…å‡ºç¯„åœ: {cgIndex}");
        }
    }
    
    // ğŸš« éš±è—CGï¼Œè¿”å›èƒŒæ™¯
    public void HideCG()
    {
        if (isShowingCG)
        {
            StartCoroutine(HideCGWithEffect());
            isShowingCG = false;
            currentCGIndex = -1;
            Debug.Log("éš±è—CGï¼Œè¿”å›èƒŒæ™¯");
        }
    }
}
```

### ğŸŒŠ è¦–è¦ºæ•ˆæœå¯¦ç¾
```csharp
public class CGDisplay : MonoBehaviour
{
    // ğŸŒ… èƒŒæ™¯æ·¡å…¥æ•ˆæœ
    private IEnumerator FadeToBackground(Sprite newBackground)
    {
        // æº–å‚™æ–°èƒŒæ™¯
        Image tempBackground = CreateTempBackgroundImage();
        tempBackground.sprite = newBackground;
        tempBackground.color = new Color(1, 1, 1, 0);
        
        // æ·¡å…¥å‹•ç•«
        float elapsedTime = 0;
        while (elapsedTime < fadeSpeed)
        {
            elapsedTime += Time.deltaTime;
            float alpha = fadeCurve.Evaluate(elapsedTime / fadeSpeed);
            
            // æ–°èƒŒæ™¯æ·¡å…¥
            tempBackground.color = new Color(1, 1, 1, alpha);
            // èˆŠèƒŒæ™¯æ·¡å‡º
            backgroundImage.color = new Color(1, 1, 1, 1 - alpha);
            
            yield return null;
        }
        
        // å®Œæˆåˆ‡æ›
        backgroundImage.sprite = newBackground;
        backgroundImage.color = Color.white;
        Destroy(tempBackground.gameObject);
    }
    
    // ğŸ¬ CGé¡¯ç¤ºæ•ˆæœ
    private IEnumerator ShowCGWithEffect(int cgIndex)
    {
        Image cgImage = cgImages[cgIndex];
        cgImage.gameObject.SetActive(true);
        cgImage.color = new Color(1, 1, 1, 0);
        
        // CGæ·¡å…¥æ•ˆæœ
        float elapsedTime = 0;
        while (elapsedTime < fadeSpeed * 0.8f) // CGé¡¯ç¤ºç¨å¿«ä¸€äº›
        {
            elapsedTime += Time.deltaTime;
            float alpha = fadeCurve.Evaluate(elapsedTime / (fadeSpeed * 0.8f));
            cgImage.color = new Color(1, 1, 1, alpha);
            yield return null;
        }
        
        cgImage.color = Color.white;
        
        // é€šçŸ¥å…¶ä»–ç³»çµ±CGå·²é¡¯ç¤º
        NotifyCGDisplayed(cgIndex);
    }
    
    // ğŸš« CGéš±è—æ•ˆæœ
    private IEnumerator HideCGWithEffect()
    {
        if (currentCGIndex >= 0)
        {
            Image cgImage = cgImages[currentCGIndex];
            
            // CGæ·¡å‡ºæ•ˆæœ
            float elapsedTime = 0;
            while (elapsedTime < fadeSpeed * 0.6f) // CGéš±è—æ›´å¿«
            {
                elapsedTime += Time.deltaTime;
                float alpha = 1 - fadeCurve.Evaluate(elapsedTime / (fadeSpeed * 0.6f));
                cgImage.color = new Color(1, 1, 1, alpha);
                yield return null;
            }
            
            cgImage.color = new Color(1, 1, 1, 0);
            cgImage.gameObject.SetActive(false);
        }
        
        // é€šçŸ¥å…¶ä»–ç³»çµ±CGå·²éš±è—
        NotifyCGHidden();
    }
}
```

---

## ğŸ–¼ï¸ èƒŒæ™¯ç®¡ç†ç³»çµ±

### ğŸ¯ BackgroundManager èƒŒæ™¯ç®¡ç†å™¨
```csharp
public class BackgroundManager : MonoBehaviour
{
    [Header("èƒŒæ™¯è³‡æº")]
    public BackgroundData[] backgroundDatabase;
    public Dictionary<string, Sprite> backgroundCache;
    
    [Header("é è¼‰å…¥è¨­å®š")]
    public bool enablePreloading = true;
    public string[] preloadScenes; // éœ€è¦é è¼‰å…¥çš„å ´æ™¯
    
    void Start()
    {
        InitializeBackgroundSystem();
        
        if (enablePreloading)
        {
            StartCoroutine(PreloadBackgrounds());
        }
    }
    
    private void InitializeBackgroundSystem()
    {
        backgroundCache = new Dictionary<string, Sprite>();
        
        // è¼‰å…¥èƒŒæ™¯æ•¸æ“šåº«
        LoadBackgroundDatabase();
    }
    
    // ğŸ”„ é è¼‰å…¥èƒŒæ™¯åœ–ç‰‡
    private IEnumerator PreloadBackgrounds()
    {
        foreach (string sceneName in preloadScenes)
        {
            BackgroundData bgData = GetBackgroundData(sceneName);
            if (bgData != null && !backgroundCache.ContainsKey(sceneName))
            {
                // ç•°æ­¥è¼‰å…¥èƒŒæ™¯åœ–ç‰‡
                var loadRequest = Resources.LoadAsync<Sprite>(bgData.resourcePath);
                yield return loadRequest;
                
                if (loadRequest.asset != null)
                {
                    backgroundCache[sceneName] = loadRequest.asset as Sprite;
                    Debug.Log($"é è¼‰å…¥èƒŒæ™¯: {sceneName}");
                }
            }
            
            yield return null; // åˆ†å¹€è¼‰å…¥ï¼Œé¿å…å¡é “
        }
        
        Debug.Log($"èƒŒæ™¯é è¼‰å…¥å®Œæˆï¼Œå…±è¼‰å…¥ {backgroundCache.Count} å€‹èƒŒæ™¯");
    }
    
    // ğŸ¨ ç²å–èƒŒæ™¯åœ–ç‰‡
    public Sprite GetBackground(string sceneName)
    {
        // å„ªå…ˆå¾å¿«å–ä¸­ç²å–
        if (backgroundCache.ContainsKey(sceneName))
        {
            return backgroundCache[sceneName];
        }
        
        // å³æ™‚è¼‰å…¥
        BackgroundData bgData = GetBackgroundData(sceneName);
        if (bgData != null)
        {
            Sprite bgSprite = Resources.Load<Sprite>(bgData.resourcePath);
            if (bgSprite != null)
            {
                backgroundCache[sceneName] = bgSprite;
                return bgSprite;
            }
        }
        
        Debug.LogWarning($"æ‰¾ä¸åˆ°èƒŒæ™¯: {sceneName}");
        return null;
    }
}

[System.Serializable]
public class BackgroundData
{
    public string sceneName;        // å ´æ™¯åç¨±
    public string resourcePath;     // è³‡æºè·¯å¾‘
    public string description;      // å ´æ™¯æè¿°
    public bool isSpecialCG;       // æ˜¯å¦ç‚ºç‰¹æ®ŠCG
}
```

---

## ğŸ­ CGèˆ‡æ¼”å“¡ç³»çµ±æ•´åˆ

### ğŸ”— CGActorIntegration æ•´åˆæ§åˆ¶å™¨
```csharp
public class CGActorIntegration : MonoBehaviour
{
    [Header("ç³»çµ±å¼•ç”¨")]
    public CGDisplay cgDisplay;
    public ActorManagerDrama actorManager; // âš ï¸ å°‡éš¨æ¼”å“¡ç³»çµ±æ”¹å‹•è€Œèª¿æ•´
    
    [Header("æ•´åˆè¨­å®š")]
    public LayerPriority displayPriority;
    public Vector2[] actorPositions; // æ¼”å“¡åœ¨ä¸åŒCGä¸­çš„ä½ç½®
    
    // ğŸ¯ CGèˆ‡æ¼”å“¡å”èª¿é¡¯ç¤º
    public void CoordinateActorWithCG(int cgIndex, string actorId)
    {
        // 1. é¡¯ç¤ºå°æ‡‰çš„CGèƒŒæ™¯
        cgDisplay.DisplayCGScene(cgIndex);
        
        // 2. èª¿æ•´æ¼”å“¡ä½ç½®å’Œé¡¯ç¤º
        AdjustActorForCG(actorId, cgIndex);
        
        // 3. è¨­å®šé¡¯ç¤ºå„ªå…ˆç´š
        SetDisplayPriority(cgIndex);
    }
    
    private void AdjustActorForCG(string actorId, int cgIndex)
    {
        // âš ï¸ æ³¨æ„ï¼šæ­¤éƒ¨åˆ†å°‡éš¨æ¼”å“¡ç³»çµ±å¤§æ”¹å‹•è€Œéœ€è¦é‡æ–°è¨­è¨ˆ
        
        if (actorManager != null)
        {
            // æ ¹æ“šCGèª¿æ•´æ¼”å“¡ä½ç½®
            if (cgIndex < actorPositions.Length)
            {
                Vector2 targetPosition = actorPositions[cgIndex];
                actorManager.SetActorPosition(actorId, targetPosition);
            }
            
            // èª¿æ•´æ¼”å“¡é¡¯ç¤ºè¨­å®š
            actorManager.SetActorLayerOrder(actorId, GetActorLayerOrder(cgIndex));
        }
    }
    
    private void SetDisplayPriority(int cgIndex)
    {
        // è¨­å®šCGå’Œæ¼”å“¡çš„é¡¯ç¤ºå„ªå…ˆç´š
        switch (displayPriority)
        {
            case LayerPriority.CGFirst:
                // CGåœ¨å‰ï¼Œæ¼”å“¡åœ¨å¾Œ
                cgDisplay.SetSortingOrder(100);
                actorManager.SetGlobalSortingOrder(50);
                break;
                
            case LayerPriority.ActorFirst:
                // æ¼”å“¡åœ¨å‰ï¼ŒCGåœ¨å¾Œ
                cgDisplay.SetSortingOrder(50);
                actorManager.SetGlobalSortingOrder(100);
                break;
                
            case LayerPriority.Balanced:
                // æ ¹æ“šå ´æ™¯å‹•æ…‹èª¿æ•´
                DynamicPriorityAdjustment(cgIndex);
                break;
        }
    }
}

public enum LayerPriority
{
    CGFirst,     // CGå„ªå…ˆé¡¯ç¤º
    ActorFirst,  // æ¼”å“¡å„ªå…ˆé¡¯ç¤º
    Balanced     // å‹•æ…‹å¹³è¡¡
}
```

---

## ğŸ® å°è©±ç³»çµ±æ•´åˆ

### ğŸ’¬ CGè§¸ç™¼æ©Ÿåˆ¶
```csharp
public class CGDialogIntegration : MonoBehaviour
{
    [Header("å°è©±è§¸ç™¼")]
    public TextBoxDrama textBoxDrama;
    public CGDisplay cgDisplay;
    
    // ğŸ¯ æ ¹æ“šå°è©±å…§å®¹è§¸ç™¼CG
    public void ProcessDialogCGCommand(DialogDataDetail dialogData)
    {
        // æª¢æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ›CG
        if (dialogData.switchCGDisplay)
        {
            ProcessCGSwitch(dialogData);
        }
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ›èƒŒæ™¯
        if (HasBackgroundCommand(dialogData))
        {
            ProcessBackgroundSwitch(dialogData);
        }
        
        // æª¢æŸ¥å ´æ™¯è½‰æ›éœ€æ±‚
        if (dialogData.needTransition)
        {
            ProcessSceneTransition(dialogData);
        }
    }
    
    private void ProcessCGSwitch(DialogDataDetail dialogData)
    {
        // æ ¹æ“šå°è©±æ•¸æ“šä¸­çš„CGæŒ‡ä»¤åˆ‡æ›å ´æ™¯
        if (dialogData.switchCGImage)
        {
            // åˆ‡æ›åˆ°æ–°çš„CGå ´æ™¯
            int cgIndex = GetCGIndexFromDialog(dialogData);
            cgDisplay.DisplayCGScene(cgIndex);
        }
        else
        {
            // éš±è—ç•¶å‰CG
            cgDisplay.HideCG();
        }
    }
    
    private void ProcessBackgroundSwitch(DialogDataDetail dialogData)
    {
        // èƒŒæ™¯åˆ‡æ›é‚è¼¯
        string backgroundName = GetBackgroundNameFromDialog(dialogData);
        Sprite newBackground = backgroundManager.GetBackground(backgroundName);
        
        if (newBackground != null)
        {
            cgDisplay.DisplayBackGroundChick(GetBackgroundIndex(backgroundName));
        }
    }
}
```

---

## ğŸ“Š æœªä¾†JSONé©…å‹•CGç³»çµ±

### ğŸ¨ CGå ´æ™¯JSONçµæ§‹è¨­è¨ˆ
```json
{
  "cgScenes": {
    "bedroom_morning": {
      "backgroundImage": "bg_bedroom_morning",
      "cgLayers": [
        {
          "layerName": "base_scene",
          "imagePath": "CG/bedroom_morning_base",
          "zOrder": 1
        },
        {
          "layerName": "character_overlay", 
          "imagePath": "CG/yuka_bedroom_overlay",
          "zOrder": 2,
          "conditions": {
            "character": "yuka",
            "expression": "happy"
          }
        }
      ],
      "transitions": {
        "fadeIn": {"duration": 1.0, "curve": "smooth"},
        "fadeOut": {"duration": 0.8, "curve": "smooth"}
      },
      "actorIntegration": {
        "hideActors": false,
        "actorPositions": {
          "yuka": {"x": 200, "y": 100},
          "player": {"x": -200, "y": 100}
        },
        "displayPriority": "balanced"
      }
    }
  },
  
  "backgroundScenes": {
    "living_room": {
      "resourcePath": "Backgrounds/living_room",
      "preload": true,
      "variants": ["morning", "evening", "night"]
    },
    "beach": {
      "resourcePath": "Backgrounds/beach",
      "preload": false,
      "specialEffects": ["waves", "sunset"]
    }
  }
}
```

---

## ğŸ”§ é–‹ç™¼å»ºè­°

### ğŸ’¡ CGç³»çµ±å¯¦ä½œæŒ‡å°
1. **è³‡æºç®¡ç†**: ä½¿ç”¨å¿«å–æ©Ÿåˆ¶æé«˜è¼‰å…¥æ•ˆç‡
2. **è¨˜æ†¶é«”å„ªåŒ–**: åŠæ™‚å¸è¼‰ä¸éœ€è¦çš„CGè³‡æº
3. **è¦–è¦ºæ•ˆæœ**: æä¾›æµæš¢çš„è½‰å ´å‹•ç•«
4. **æ•´åˆæ€§**: èˆ‡å°è©±ç³»çµ±å’Œæ¼”å“¡ç³»çµ±ç·Šå¯†é…åˆ

### âš ï¸ æ³¨æ„äº‹é …
- **æ¼”å“¡ç³»çµ±å…¼å®¹**: éš¨è‘—æ¼”å“¡ç³»çµ±å¤§æ”¹å‹•ï¼Œéœ€è¦èª¿æ•´æ•´åˆä»‹é¢
- **è³‡æºè·¯å¾‘**: ç¢ºä¿CGè³‡æºè·¯å¾‘çš„ä¸€è‡´æ€§
- **æ•ˆèƒ½è€ƒé‡**: å¤§åœ–ç‰‡çš„è¼‰å…¥å’Œé¡¯ç¤ºå¯èƒ½å½±éŸ¿æ•ˆèƒ½
- **UIå±¤ç´š**: åˆç†å®‰æ’CGã€æ¼”å“¡ã€UIçš„é¡¯ç¤ºå±¤ç´š

### ğŸ¯ æ•ˆèƒ½å„ªåŒ–å»ºè­°
- **åˆ†è¾¨ç‡ç®¡ç†**: æ ¹æ“šè¨­å‚™æ€§èƒ½è¼‰å…¥ä¸åŒåˆ†è¾¨ç‡çš„CG
- **ç•°æ­¥è¼‰å…¥**: ä½¿ç”¨å”ç¨‹é¿å…è¼‰å…¥æ™‚çš„å¡é “
- **è¨˜æ†¶é«”æ± **: é‡ç”¨å¸¸ç”¨çš„CGé¡¯ç¤ºçµ„ä»¶
- **å£“ç¸®æ ¼å¼**: é¸æ“‡åˆé©çš„åœ–ç‰‡å£“ç¸®æ ¼å¼

---

## ğŸ”— ç›¸é—œæ¶æ§‹æ–‡ä»¶å°è¦½

### ğŸ­ åŠ‡æƒ…æ¨¡å¼æ•´åˆ
- **ğŸ¬ åŠ‡æƒ…å ´æ™¯ç®¡ç†**: [`åŠ‡æƒ…å ´æ™¯ç®¡ç†.md`](./åŠ‡æƒ…å ´æ™¯ç®¡ç†.md) - CGDisplayçš„ä¸Šå±¤ç®¡ç†
- **ğŸ¯ åŠ‡æƒ…æµç¨‹æ§åˆ¶**: [`åŠ‡æƒ…æµç¨‹æ§åˆ¶.md`](./åŠ‡æƒ…æµç¨‹æ§åˆ¶.md) - CGè§¸ç™¼æ™‚æ©Ÿæ§åˆ¶
- **ğŸ’« å ´æ™¯è½‰æ›ç³»çµ±**: [`å ´æ™¯è½‰æ›ç³»çµ±.md`](./å ´æ™¯è½‰æ›ç³»çµ±.md) - CGåˆ‡æ›æ•ˆæœ

### ğŸ”„ ç³»çµ±æ•´åˆ
- **ğŸ’¬ å°è©±ç³»çµ±**: [`../SharedSystems/å°è©±ç³»çµ±æ¶æ§‹.md`](../SharedSystems/å°è©±ç³»çµ±æ¶æ§‹.md) - CGè§¸ç™¼æŒ‡ä»¤
- **ğŸ­ æ¼”å“¡æ§åˆ¶**: [`../SharedSystems/æ¼”å“¡æ§åˆ¶æ¶æ§‹.md`](../SharedSystems/æ¼”å“¡æ§åˆ¶æ¶æ§‹.md) - CGèˆ‡æ¼”å“¡é…åˆ

---

## ğŸ’¬ Claude ä½¿ç”¨æç¤º

### ğŸ¯ CGç³»çµ±é–‹ç™¼é‡é»
1. **è¦–è¦ºé«”é©—**: ç¢ºä¿CGåˆ‡æ›çš„æµæš¢æ€§å’Œè¦–è¦ºæ•ˆæœ
2. **è³‡æºç®¡ç†**: é«˜æ•ˆçš„åœ–ç‰‡è¼‰å…¥å’Œè¨˜æ†¶é«”ç®¡ç†
3. **ç³»çµ±æ•´åˆ**: èˆ‡å°è©±å’Œæ¼”å“¡ç³»çµ±çš„ç„¡ç¸«é…åˆ
4. **æ“´å±•æ€§**: æ”¯æ´æœªä¾†æ–°å¢çš„CGå ´æ™¯å’Œæ•ˆæœ

### ğŸš¨ **æ¼”å“¡ç³»çµ±æ”¹å‹•å½±éŸ¿**
- CGèˆ‡æ¼”å“¡ä½ç½®èª¿æ•´åŠŸèƒ½éœ€è¦é‡æ–°è¨­è¨ˆ
- é¡¯ç¤ºå„ªå…ˆç´šç®¡ç†å¯èƒ½éœ€è¦èª¿æ•´
- æ•´åˆä»‹é¢å°‡éš¨æ–°æ¼”å“¡ç³»çµ±è€Œæ”¹è®Š

---

**æœ€å¾Œæ›´æ–°**: 2025-07-29  
**ç‰ˆæœ¬**: 1.0 (CGå±•ç¤ºç³»çµ±æ¶æ§‹)  
**ç¶­è­·è€…**: é–‹ç™¼åœ˜éšŠ + Claude AI

> ğŸ–¼ï¸ **æ ¸å¿ƒæé†’**: CGå±•ç¤ºç³»çµ±æ˜¯åŠ‡æƒ…æ¨¡å¼è¦–è¦ºé«”é©—çš„é—œéµï¼Œéœ€è¦èˆ‡å°è©±ç³»çµ±å’Œæ¼”å“¡ç³»çµ±ç·Šå¯†é…åˆã€‚éš¨è‘—æ¼”å“¡ç³»çµ±çš„å¤§æ”¹å‹•ï¼Œç›¸é—œæ•´åˆåŠŸèƒ½éœ€è¦åŒæ­¥èª¿æ•´ã€‚